#+setupfile: setup.org
#+TITLE: Лекций 5
#+date: 29 сентября
#+LATEX_HEADER: \newcommand{\idx}[2]{{#1}^{(#2)}}

* Сверточные коды
#+NAME: Сверточные коды_rem
#+begin_rem org
Задача кодера -- сделать передаваемые символы статистически зивисимыми
- Блоковые коды: функциональное преобразование блоков данных в кодовые слова
- Сверточные коды: автоматное отображение блоков данных в кадры колового слова

Простейший автомат -- регистр сдвига. Кодер может хранить \(m\) ранее поступивших блоков из \(k_0\) символов. На каждом шане кодер выдает \(n_0\) закодированных символов. Скорость кода \(R = \frac{k_0}{n_0}\). Объем памяти кодера -- длина кодового ограничения \(K = mk_0\).
#+end_rem

#+NAME: Сверточные коды_examp
#+begin_examp org
\-
- \(k_0 = 1, m = 2, K = k_0m = 2, n_0 = 2\)
- \(g^{(1)}(x) = x^2 + 1, g^{(2)}(x) = x^2 + x + 1\)

#+begin_export latex
\begin{center}
\begin{tikzpicture}
\draw[draw=black,fill=yellow] (0, 0) rectangle ++(6, 2);
\draw[draw=black,fill=black,thick] (2, 0) to (2, 2);
\draw[draw=black,fill=black,thick] (4, 0) to (4, 2);

\node at (-3, 1.5) {\(a(x) = \dots + a_{n-1}x^{n-1} + a_nx^n\)};
\draw[->, thick] (-2, 1) to (0, 1);

\node[circle,draw] (u) at (3, 4) {\(+\)};
\node[circle,draw] (d) at (3, -2) {\(+\)};

\draw[->, thick] (1, 0) -- node[left] {\(x^2\)} (d);
\draw[->, thick] (3, 0) -- node[left] {\(x^1\)} (d);
\draw[->, thick] (5, 0) -- node[left] {\(x^0\)} (d);

\draw[->, thick] (1, 2) -- (u);
\draw[->, thick] (5, 2) -- (u);

\draw[->, thick] (u) -- node[above] {\(c^{(1)}(x)\)} ++(2, 0);
\draw[->, thick] (d) -- node[above] {\(c^{(2)}(x)\)} ++(2, 0);
\end{tikzpicture}
\end{center}
#+end_export
#+end_examp

** Порождающая матрица сверточного кода
#+NAME: Сверточные коды
#+begin_rem org
\(k_0 = 1\): Выходная последовательность -- линейная свертка информационной последовательности и порождащих многочленов кода
\[ c^{(i)}(x) = c_0^{(i)} + c_1^{(i)}x + \dots = a(x) g^{(i)}(x) = \sum_{j \ge 0} x^j \sum^m_{t = 0} a_{j - t}g_t^{(i)}, 1 \le i \le n_0 \]
Теоретически кодовые слова имеют бесконечную длину. В практических системах длина кодового слова фиксирована. В конец информационной последовательности вводят несколько дополнительных битов, переводящих регистр сдвига в нулевое состояние.

Кодирование в общем случае
\[(c^{(1)}(x), \dots, \idx{c}{n_0}) = (\idx{a}{1}(x), \dots, \idx{a}{k_0}(x))G(x) \]
\(G(x)\) -- \(k_0 \times n_0\) порождающая матрица (многочленная) кода
#+end_rem

#+NAME: Сверточные коды_lin
#+begin_rem org
Сверточные коды являеются линейными
#+end_rem


#+NAME: Способы представления
#+begin_rem org
Графическое представление сверточных кодов:
- Последовательности возможных переходов конечного автомата могут быть представлены в виде дерева. Древовидная диаграмма обладает свойством самоподобия
- Решетчатая диаграмма -- боле компактный способ задания кода
- Кодовое слово -- путь в решетке, начинающийся и заканчивающийся в нулевом состоянии. Фиксированная длина. Предполагается, что после обработки информационной последовательности были поданы несколько дополнительных битов, переводящих регистр сдвига в нулевое состояние
#+end_rem

** Корректирующая способность
#+begin_definition org
Минимальное расстояние Хемминга для любых последовательностей из \(l\) кадров, отличающихся начальным кадром, называется *\(l\)-м минимальным расстоянием кода \(d^*_l\)*.
#+end_definition

#+begin_symb org
\(d^*_{m+1}\) -- минимальное расстояние кода
#+end_symb

#+begin_definition org
Последовательность \(d_1^*, d_2^*, d_3^*, \dots\) называется *дистанционным профилем кода*
#+end_definition

#+begin_statement org
Если в первых \(l\) кадрах произошло \(t\) ошибок, то первый кадр может быть исправлен при условии \(2t + 1 \le d_l^*\)
#+end_statement

#+begin_definition org
*Минимальное свободное расстояние кода* \(d_{\text{frcc}} = \max_l d_l^*\)
#+end_definition

#+begin_rem org
Свободная длина \(n_{\text{rfcc}}\) кода -- длина имеющего наименьший вес ненулевого начального сегмента кодовой последовательности сверточного кода
#+end_rem

** Катастрофические кодеры (порождающие матрицы)
#+NAME: Катастрофические порождающие матрицы
#+begin_definition org
*Катастрофический кодер* отображает информационные последовательности бесконечного веса в кодовые последовательности конечного веса
#+end_definition

#+begin_rem org
КК характеризуется наличием петель нулевого веса в графе переходов
#+end_rem

#+NAME: Катастрофические порождающие матрицы_examp
#+begin_examp org
Порождающая матрица катастрофического кодера \(G(x) = (x^2 + 1, x^2 + 1)\). Единичные ошибки в канале могут привести к бесконечному числу ошибок декодера. Если при передаче нулевого кодового слова возникла ошибка вида \(\dots 00011000\dots\), то она будет продекодирована в информационную последовательность вида \(\dots 000101010101 \dots\), то она будет продекодирована в информационную последовательность вида \(\dots 000101010101 \dots\)
#+begin_export latex
\begin{center}
\begin{tikzpicture}
  \node[state, initial] (s0) at (0, 3) {\(00\)};
  \node[state] (s1) at (0, 0) {\(01\)};
  \node[state] (s2) at (3, 3) {\(10\)};
  \node[state] (s3) at (3, 0) {\(11\)};

  \draw[->] (s0) edge[loop above] node {\(0|00\)} (s0)
            (s0) edge[above] node {\(1 | 11\)} (s2)
            (s2) edge[right] node {\(1 | 11\)} (s3)
            (s2) edge[bend right,left] node {\(0 | 00\)} (s1)
            (s3) edge[below] node {\(0 | 11\)} (s1)
            (s3) edge[loop below] node {\(1 | 00\)} (s3)
            (s1) edge[left] node {\(0 | 11\)} (s0)
            (s1) edge[bend right, right] node {\(1 | 00\)} (s2);
\end{tikzpicture}
\end{center}
#+end_export
#+end_examp

#+begin_rem org
Ошибка декодирования при исользовании некатастрофического кодера приводит к ограниченному числу ошибок на выходe декодера
#+end_rem


#+NAME: Катастрофические порождающие матрицы_th
#+begin_theorem org
Порождающая матрица не является катастрофической ттогда, когда НОД определителей всех \(k_0 \times k_0\) подматриц \(G(x)\) равен \(x^s, s \ge 0\).
#+end_theorem


** Систематическое кодирование
#+begin_definition org
*Систематическое кодирование* -- информационная последовательность является подпоследовательностью кодовой последовательности
#+end_definition

Любой сверточный код может быть преобразован к эквивалентному систематическому коду за счет введения фильтра с бесконечным импульсным откликом. Это преобразование информационной последовательности является биективным и не влияет на корректирующие свойства кода.

#+begin_statement org
Порождающая матрица \(G(x)\) может быть приведена к каноническому виду аналогично случаю линейных блоковых кодов (Преобразование над полем рациональных функций)
#+end_statement

Некоторые информационные последовательности конечного веса могут попродить кодовые слова бесконечного веса

\[ G(x) = (x^2 + 1, x^2 + x + 1) \to \left( \frac{x^2 + 1}{x^2 + x - 1}, 1 \right) \]
\todo Картинка
# https://youtu.be/o7eM7uBfNnY?list=PLd7QXkfmSY7YEom7j8DGk8EBw5O5SZDQs&t=1219
#+begin_examp org
\(a(x) = 1 + x^4 + x^5; a(x)G(x) = [1 + x + x^2 + x^5, 1 + x^4 + x^5]\)
#+begin_export latex
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
шаг & вход & содержимое регистра & выход 0 & выход 1 \\ \hline
0 & 1 & 100 & 1 & 1 \\ \hline
1 & 1 & 010 & 0 & 1 \\ \hline
2 & 0 & 101 & 0 & 0 \\ \hline
3 & 0 & 110 & 1 & 0 \\ \hline
4 & 0 & 011 & 1 & 0 \\ \hline
5 & 1 & 001 & 1 & 1 \\ \hline
\end{tabular}
\end{center}
#+end_export
#+end_examp


* Декодирование сверточных кодов
** Алгоритм Витерби
Декодирование по критерию максимума праводоподобия (= минимального расстояния). Кодовые слова соответсвуют путям в решетке
#+begin_examp org
\todo Картинка
# https://youtu.be/o7eM7uBfNnY?list=PLd7QXkfmSY7YEom7j8DGk8EBw5O5SZDQs&t=1815
#+end_examp

** Производящая функция

#+NAME: Производящая функция сверточных кодов
#+begin_rem org
Вероятность ошибки декодирования кода определяется числом кодовых слов различного веса. Число путей в решетке, начинающихся и заканчивающихся в нулевом состоянии

Пометим ребра графа переходов метками \(D^i\), где \(i\) -- вес кодовой последовательности. Последовательность символов веса \(x\) характеризуется одночленом \(D^x\). Совокупность кодовых слов характеризуется многочленом, например \(2D^6 + 3D^8\).
Расщепим исходное состояние на два: начальное \((0)\) и конечное \((e)\). Пусть \(X_i\) характеризует совокупность кодовых последовательностей, приводящих кодер в состояние \(i\).
\(X_i\) -- ряд, коэффиценты которого равны числу кодовых последовательностей, начинающихся в нулевом и заканчивающихся в \(i\)-ом состоянии.
Производящая функция \(T(D)\) равна \(X_e / X_a\). Это степенной ряд, коэффиценты которого равны числу кодовых слов различного веса, выходящих из нулевого состояния и возвращающихся в него

Степень нунелувого члена -- минимальное свободное расстояние кода. Минимальное свободное расстояние пропорционально длине кодового ограничения.
При фиксированной длине блока сверточные коды хуже аналогичных блоковых
#+end_rem

#+NAME: Производящая функция сверточных кодов_examp
#+begin_examp org
\-
#+begin_export latex
\begin{center}
\begin{align*}
\begin{cases}
X_b = D^2 X_a + X_d \\
X_c = D X_b + D X_c \\
X_d = D X_c + D X_b \\
X_e = D^2 X_d
\end{cases} \\
T(D) = \frac{D^5}{1 - 2D} = D^5 + 2D^6 + 4 D^7 + 8 D^8
\end{align*}
\end{center}
#+end_export
#+begin_export latex
\begin{center}
\begin{tikzpicture}
\node (e) at (0, 0) [draw,fill=blue,circle] {\(00|e\)};
\node (d) at (3, 0) [draw,fill=blue,circle] {\(01|d\)};
\node (c) at (6, 0) [draw,fill=blue,circle] {\(11|c\)};
\node (b) at (6, 3) [draw,fill=blue,circle] {\(10|b\)};
\node (a) at (3, 3) [draw,fill=blue,circle] {\(00|a\)};

\draw[->] (d) edge node[above] {\(11/D^2\)} (e);
\draw[->] (c) edge node[above] {\(10/D\)} (d);
\draw[->] (c) edge[loop below] node[below] {\(01/D\)} (c);
\draw[->] (b) edge node[right] {\(10/D\)} (c);
\draw[->] (b) edge[bend right] node[above,left] {\(01/D\)} (d);
\draw[->] (d) edge node[below,right] {\(00/D^0\)} (b);
\draw[->] (a) edge node[above] {\(11/D^2\)} (b);
\end{tikzpicture}
\end{center}
#+end_export

#+end_examp


** Расширенная производящая функция
Исследуем зависимость веса кодового слова от веса информационной последовательности. Пометим ребра графа переходов метками \(N^jD^i\), где \(i\) -- вес выходной последовательности
- \(j = 0\) -- переход по \(0\)
- \(j = 1\) -- переход по \(1\)

#+begin_definition org
Расширенная производящая функция -- степенной ряд от переменных \(N\) и \(D\), в котором коэффициент при \(N^aD^b\) равен числу кодовых последовательностей веса \(b\), порождаемых информационными последовательностями веса \(a\).
#+end_definition

#+begin_examp org
\-
#+begin_export latex
\begin{center}
\begin{align*}
\begin{cases}
X_b = ND^2 X_a + ND^0X_d \\
X_c = ND X_b + ND X_c \\
X_d = D X_c + D X_b \\
X_e = D^2 X_d
\end{cases} \\
T(D) = \frac{ND^5}{1 - 2D} = ND^5 + 2N^2D^6 + 4N^3 D^7 + 8N^4 D^8
\end{align*}
\end{center}
#+end_export
\todo Картинка ez
# https://youtu.be/o7eM7uBfNnY?list=PLd7QXkfmSY7YEom7j8DGk8EBw5O5SZDQs&t=2715
#+end_examp


** Вероятность ошибки декодирования (канал с АБГШ)
Вероятность ошибки декодирования (канал с АБГШ)
\[ r_{ij} = (-i)^{c_{ij}} + \eta_{ij}, \eta_{ij} \sim N(0, \sigma^2), 1 \le j \le n_0, i=0,1,\dots \]
Предположим, что передавалосб нулевое кодовое слово. Будем считать, что алгоритм Витерби ищет последовательность с максимальной корреляцией \(C = \sum_{i \ge 0} \sum_{j=1}^{n_0} r_{ij} (-1)^{c_{ij}}\).

Оценим вероятность первого события неправильного декодирвания. Ошибка произойдет, если при слиянии нескольких путей на некотором ярусе \(B\) окажется, что \(C_1 > C_0\). \(С_0\) -- метрика ненулевого пути \(c_{ij}\), \(C_1\) -- метрика нулевого пути
\[ P\{C_1 > C_0\} = P \left\{ \sum_{i=0}^B \sum_{j=1}^{n_0} r_{ij} ((-1)^{c_{ij}} - 1) > 0) \right\} = P \left\{ \sum_{i=0}^B \sum_{j:c_{ij} \neq 0} r_{ij} < 0\right\} \]

Объединенная верхняя граница вероятности ошибки декодирования:
- \(r_{ij} \sum N(1, \sigma^2)\)
Если неправильный путь имеет вес \(d\) на ярусах \(0, \dots, B\), то:
\[ p = \sum_{i=0}^B \sum_{j:c_{ij} \neq 0} r_{ij} \sim N(d, d\sigma^2), \sigma^2 = \frac{N_0}{2} \]
\[ P_d = P\{p<0\} = Q\left(\sqrt{2d \frac{E_b}{N_0}}\right) = Q\left(\sqrt{2dR \frac{E_b}{N_0}}\right), Q(x) = \frac{1}{\sqrt{2\pi}} \int_x^\infty e^{- t^2 / 2} dt = \frac{1}{2} \mathOp{\rm erfc} (x / \sqrt{2}) \]
Вероятность ошибки -- вероятность того, что будет выбран какой-либо неправильный путь
\[ P_C = P \{(C_1 > C_0) \lor (C_2 > C_0) \lor \dots \} \le \sum_i P\{C_i > C_0\} = \sum_{d > 0} t_d P_d = \sum_{d = d ?}^\infty t_d Q\left(\sqrt{2dR \frac{E_b}{N_0}}\right) \]
Производящая функция \(T(D) = \sum_{d \ge 0} t_d D^d\)

Вероятность ошибки на бит в случае выборп ошибочного пути \(C_i\) с кодовой и информационной последовательности отичающихся от истснных в \(d\)  и \(w\) позициях, соответсвенно, равна \(\frac{w}{k_0} P\{C_i > C_0\} = \frac{w}{k_0} P_d\).
Расширенная производящая функция \(T(N, D) = \sum_{w,d}t_{wd} N^w D^d\).
\[ t(D) = \left. \frac{\partial T(N, d)}{\partial N} \right|_{N=1} = \sum_d D^d \underbrace{\sum_w t_{wd}w}_{b_d} \]
Общая вероятность ошибки декодирования на бит
\[ P_b \le \frac{1}{k_0} \sum_{d = d_{f?}}^\infty b_d Q\left(\sqrt{2dR\frac{E_b}{N_0}}\right) \]

** Выводы
Сверточные коды -- понятийно простой способ помехозащиты. Сложность декодирования алгритмом Витерби растет экспоненциально с длиной кодового ограничения и линейно с длиной кодируемой последовательности. Минимальное свободное расстояние растет с длиной кодового ограничения.

* Комибинирование кодов
** Конструкция Плоткина
#+NAME: Конструкция Плоткина
#+begin_theorem org
Пусть даны \((n, k, d)\) коды \(C_i, i=1,2\), \(C=\{(c_1, c_1 + c_2)|c_i \in C_i, i=1,2\}\) -- \((2n, k_1 + k_2, \min(2d_1, d_2))\) код
#+end_theorem

#+begin_proof org
\(C\) содержит кодовые слова \((c_1, c_1), c_1 \in C_1, (0, c_2), c_2 \in C \implies d \le 2d_1, d \le d_2\)
- Пусть \(c_1, c_1' \in C_1 \setminus \{0\}, c_2, c_2' \in C_2 \setminus \{0\}\) -- ненулевые кодовые слова компонентных кодов
#+begin_export latex
\begin{center}
\begin{equation*}
d((c_1, c_1 + c_2), (c_1', c_1' + c_2')) = d(c_1, c_1') + d(c_1 + c_2, c_1' + c_2') \\
c_2 = c_2' \land c_1 \neq c_1' \implies d(c_1, c_1') + d(c_1 + c_2, c_1' + c_2') = d(c_1, c_1') + d(c_1, c_1') \le 2d_1
\end{equation*}
\end{center}
\begin{center}
\begin{align*}
c_2 \neq c_2' \implies d(c_1, c_1') + d(c_1 + c_2, c_1' + c_2') & = {\rm wt}(c_1 - c_1') + {\rm wt}(c_1 - c_1' + c_2 - c_2') \ge \\
& \ge {\rm wt}(c_1 - c_1') + {\rm wt}(c_2 - c_2') - {\rm wt} (c_1 - c_1') = {\rm wt}(c_2 - c_2') \ge \\
& \ge d_2
\end{align*}
\end{center}
#+end_export
#+end_proof

** Декодирование кодов
Декодирование \((y', y'') = (c_1, c_1 + c_2) + (e', e'')\) в метрике Хемминга
\[ y''' = y'' - y' = c_1 + c_2 + e'' - c_1 - e' = c_2 + e''' \]

Продекодируем \(y'''\) декодером кода \(C_2\). Если \({\rm wt}((e', e'')) \le \lfloor (d - 1) / 2 \rfloor\), то \({\rm wt}(e''') \le {\rm wt}(e') + {\rm wt}(e'') \le \lfloor (d - 1) / 2 \rfloor \le \lfloor (d_2 - 1) / 2 \rfloor \) и декодирование выполняется правильно&

Пусть \(c_2\) найдено правильно. Продекодируем в \(C_1\) вектора \(y' = c_1 + e'\) и \(y'' - c_2 = c_1 + e''\). Если \({\rm wt}((e', e'')) = {\rm wt} (e') + {\rm wt}(e'') \le \lfloor (d - 1) / 2 \rfloor \le \lfloor (2d_1 - 1) / 2 \rfloor < d_1\), то \({\rm wt}(e') \le \lfloor (d_1 - 1) / 2 \rfloor \lor {\rm wt}(e'') \le \lfloor (d_1 - 1) / 2 \rfloor \implies \) декодирование \(y'\) или \(y''\) даст правильный результат

** Коды Рида-Маллера
#+NAME: Коды Рида-Маллера
#+begin_rem org
Рекурсивное применение конструкции Плоткина
- \(RM(r, m)\) -- код Рида-Маллера порядка \(r\) длины \(2^m\)
- \(RM(0, m) = (2^m, 1, 2^m)\)
- \(RM(m, m) = (2^m, 2^m, 1)\)
- \(RM(r + 1, m + 1)\) применение конструкции Плоткина к \(C_1 = RM(r + 1, m), C_2 = RM(r, m)\)
#+end_rem
