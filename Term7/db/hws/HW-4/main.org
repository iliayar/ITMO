#+title: HW 4

StudentId, StudentName, GroupId, GroupName, CourseId, CourseName, LecturerId, LecturerName, Mark

* 1
** 1
Функциональные зависимости:
-- У студента есть имя и он обучается в определенной группе, при чем могут быть студенты с одинаковыми именами
StudentId -> StudentName
StudentId -> GroupId
-- У группы есть название
GroupId -> GroupName
GroupName -> GroupId
-- У курса есть название, при чем названия в разных университетах могут повторяться
CourseId -> CourseName
-- У лектора есть имя
LecturerId -> LecturerName
-- Студент может иметь оценку по итогам какого-либо курса, при чем эту оценку выставил лектор этого курса
StudentId, CourseId -> Mark, LecturerId
-- Курс у группы читает определенный лектор, при чем у разныз групп один и тот же курс могут читать разные лекторы
-- Так же лектор может читать больше одного курса
GroupId, CourseId -> LecturerId

Из предыдущего ДЗ, у этого отношения единственный ключ: {StudentId, CourseId}.

Критерии 1НФ:
1. Повторяющихся групп аттрибутов нет
2. Все аттрибуты атомарны
3. Есть ключ при чем единственный

#+begin_src 
(StudentId, StudentName, GroupId, GroupName, CourseId, CourseName, LecturerId, LecturerName, Mark) => (StudentId, StudentName, GroupId, GroupName, CourseId, CourseName, LecturerId, LecturerName, Mark).
#+end_src
** 2
Найдем "мешающие" ФЗ:
1. Для аттрибута StudentId
StudentId -> StudentName
StudentId -> GroupId
StudentId -> GroupName
2. Для аттрибута CourseId
CourseId -> CourseName
GroupId, CourseId -> LecturerId

Заметим, что при разбиении по StudentId -> GroupId теряется ФЗ GroupId
-> GroupName, вместо StudentId -> GroupId, StudentId -> GroupName
разобъем по: StudentId -> GroupId, GroupName

Теперь теряем ФЗ GroupId, CourseId -> LecturerId, поэтому декомпозиуем
сначала по GroupId, CourseId -> LecturerId, LecturerName, добавив
LecurerName чтобы не потерять ФЗ LecturerId -> LecturerName

ФЗ StudentId, CourseId -> Mark, LecturerId не теряем, т.к. выводится из:
StudentId -> GroupId
GroupId, CourseId -> LecturerId
StudentId, CourseId -> Mark

1. По GroupId, CourseId -> LecturerId, LecturerName
   - (GroupId, CourseId, LecturerId, LecturerName)
   - (StudentId, StudentName, GroupId, GroupName, CourseId, CourseName, Mark)
2. По StudentId -> GroupId, GroupName
   - (GroupId, CourseId, LecturerId, LecturerName)
   - (StudentId, GroupId, GroupName)
   - (StudentId, StudentName, CourseId, CourseName, Mark)
2. По StudentId -> StudentName
   - (GroupId, CourseId, LecturerId, LecturerName)
   - (StudentId, GroupId, GroupName)
   - (StudentId, StudentName)
   - (StudentId, CourseId, CourseName, Mark)
3. По CourseId -> CourseName
   - (GroupId, CourseId, LecturerId, LecturerName)
   - (StudentId, GroupId, GroupName)
   - (StudentId, StudentName)
   - (CourseId, CourseName)
   - (StudentId, CourseId, Mark)

#+begin_src 
(StudentId, StudentName, GroupId, GroupName, CourseId, CourseName, LecturerId, LecturerName, Mark) => (GroupId, CourseId, LecturerId, LecturerName); (StudentId, GroupId, GroupName); (StudentId, StudentName); (CourseId, CourseName); (StudentId, CourseId, Mark).
#+end_src

** 3
Найдем транзитивные зависимости неключевых аттрибутов в отношенях
(GroupId, CourseId, LecturerId, LecturerName) и (StudentId, GroupId,
GroupName), т.к. остальные декмопозировать не можем, т.к. они содержат
лишь ключ и один неключевой аттрибут:

- (GroupId, CourseId, LecturerId, LecturerName)
  GroupId, CourseId -> LecturerId
  LecturerId -> LecturerName

  Декомпозируем на:
  - (GroupId, CourseId, LecturerId)
  - (LecturerId, LecturerName)

- (StudentId, GroupId, GroupName)
  StudentId -> GroupId
  GroupId -> GroupName
  GroupName -> GroupId

  Декомпозируем на:
  - (StudentId, GroupId)
  - (GroupId, GroupName)

#+begin_src 
(GroupId, CourseId, LecturerId, LecturerName) => (GroupId, CourseId, LecturerId); (LecturerId, LecturerName).
(StudentId, GroupId, GroupName) => (StudentId, GroupId); (GroupId, GroupName).
(StudentId, StudentName) => (StudentId, StudentName).
(CourseId, CourseName) => (CourseId, CourseName).
(StudentId, CourseId, Mark) => (StudentId, CourseId, Mark).
#+end_src

** 4
- (GroupId, CourseId, LecturerId)
  GroupId, CourseId -> LecturerId
  GroupId, CourseId - ключ
- (LecturerId, LecturerName)
  LecturerId -> LecturerName
  LecturerId - ключ
- (StudentId, GroupId)
  StudentId -> GroupId
  StudentId - ключ
- (GroupId, GroupName)
  GroupId -> GroupName
  GroupName -> GroupId
  GroupId - ключ, GroupName - ключ
- (StudentId, StudentName)
  StudentId -> StudentName
  StudentId - ключ
- (CourseId, CourseName)
  CourseId -> CourseName
  CourseId - ключ
- (StudentId, CourseId, Mark)
  StudentId, CourseId -> Mark
  StudentId, CourseId - ключ

Получается что уже в НФБК

#+begin_src 
(GroupId, CourseId, LecturerId) => (GroupId, CourseId, LecturerId).
(LecturerId, LecturerName) => (LecturerId, LecturerName).
(StudentId, GroupId) => (StudentId, GroupId).
(GroupId, GroupName) => (GroupId, GroupName).
(StudentId, StudentName) => (StudentId, StudentName).
(CourseId, CourseName) => (CourseId, CourseName).
(StudentId, CourseId, Mark) => (StudentId, CourseId, Mark).
#+end_src

** 5
Для всех отношений из 2х аттрибутов нет нетривиальных МЗ с
непересекающимися X, Y, рассмотрим оставшиеся:
- (GroupId, CourseId, LecturerId)
  Нет нетривиальных МЗ, т.к. GroupId, CourseId - единственный нетривиальный надключ
- (StudentId, CourseId, Mark)
  Аналогично предыдущему: (StudentId, CourseId) - единственный нетривиальный надключ

#+begin_src 
(GroupId, CourseId, LecturerId) => (GroupId, CourseId, LecturerId).
(LecturerId, LecturerName) => (LecturerId, LecturerName).
(StudentId, GroupId) => (StudentId, GroupId).
(GroupId, GroupName) => (GroupId, GroupName).
(StudentId, StudentName) => (StudentId, StudentName).
(CourseId, CourseName) => (CourseId, CourseName).
(StudentId, CourseId, Mark) => (StudentId, CourseId, Mark).
#+end_src

** 6
Рассмотрим отношения с 3мя аттрибутами, т.к. отношения с 2мя
аттрибутами имеют единственный простой ключ и находятся в 3НФ, и по теореме
Дейта-Фейгина 1 находятся в 5НФ.

- (GroupId, CourseId, LecturerId)
  GroupId, CourseId -> LecturerId
  *{{GroupId, CourseId}, {GroupId, CourseId, LecturerId}}
  Каждое разбиение содержит ключ (GroupId, CourseId), а значит и надключ
- (StudentId, CourseId, Mark)
  StudentId, CourseId -> Mark
  Аналогично предыдущему

#+begin_src 
(GroupId, CourseId, LecturerId) => (GroupId, CourseId, LecturerId).
(LecturerId, LecturerName) => (LecturerId, LecturerName).
(StudentId, GroupId) => (StudentId, GroupId).
(GroupId, GroupName) => (GroupId, GroupName).
(StudentId, StudentName) => (StudentId, StudentName).
(CourseId, CourseName) => (CourseId, CourseName).
(StudentId, CourseId, Mark) => (StudentId, CourseId, Mark).
#+end_src
* 2
* 3
* 4
#+header: :engine postgres
#+begin_src sql
CREATE DATABASE hw4;
#+end_src

#+RESULTS:
| CREATE DATABASE |
|-----------------|

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
DROP TABLE IF EXISTS Students CASCADE;
DROP TABLE IF EXISTS Groups CASCADE;
DROP TABLE IF EXISTS Lecturers CASCADE;
DROP TABLE IF EXISTS Courses CASCADE;
DROP TABLE IF EXISTS Marks CASCADE;
DROP TABLE IF EXISTS Teachers CASCADE;
DROP TABLE IF EXISTS StudentGroups CASCADE;

CREATE TABLE Students (
       Id int GENERATED ALWAYS AS IDENTITY not null,
       Name varchar(50) not null,

       PRIMARY KEY (Id)
);

CREATE TABLE Groups (
       Id int GENERATED ALWAYS AS IDENTITY not null,
       Name varchar(50) not null,

       PRIMARY KEY (Id)
);

CREATE TABLE Lecturers (
       Id int GENERATED ALWAYS AS IDENTITY not null,
       Name varchar(50) not null,

       PRIMARY KEY (Id)
);

CREATE TABLE Courses (
       Id int GENERATED ALWAYS AS IDENTITY not null,
       Name varchar(50) not null,

       PRIMARY KEY (Id)
);

CREATE TABLE Teachers (
       CourseId int not null,
       GroupId int not null,
       LecturerId int not null,
       PRIMARY KEY (CourseId, GroupId),

       FOREIGN KEY (CourseId)
       REFERENCES Courses(Id),

       FOREIGN KEY (GroupId)
       REFERENCES Groups(Id),

       FOREIGN KEY (LecturerId)
       REFERENCES Lecturers(Id)
);

CREATE TABLE Marks (
       CourseId int not null,
       StudentId int not null,
       Mark int not null,
       PRIMARY KEY (CourseId, StudentId),

       FOREIGN KEY (CourseId)
       REFERENCES Courses(Id),

       FOREIGN KEY (StudentId)
       REFERENCES Students(Id)
);

CREATE TABLE StudentGroups (
       GroupId int not null,
       StudentId int not null,
       PRIMARY KEY (StudentId),

       FOREIGN KEY (GroupId)
       REFERENCES Groups(Id)
);
#+end_src

#+RESULTS:
| DROP TABLE   |
|--------------|
| DROP TABLE   |
| DROP TABLE   |
| DROP TABLE   |
| DROP TABLE   |
| DROP TABLE   |
| DROP TABLE   |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |
| CREATE TABLE |

* 6
* 7
#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
INSERT INTO Students (Name) VALUES
       ('Иванов Иван'),
       ('Петров Петр'),
       ('Казимиров Казимир'),
       ('Игнатьев Игнат'),
       ('Тимуров Тимур'),
       ('Станиславов Станислав');
#+end_src

#+RESULTS:
| INSERT 0 6 |
|------------|

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
INSERT INTO Groups (Name) VALUES
       ('M33371'),
       ('M3133'),
       ('M34391');
#+end_src

#+RESULTS:
| INSERT 0 3 |
|------------|

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
INSERT INTO Lecturers (Name) VALUES
       ('Корнеев Георгий'),
       ('Кохась Константин'),
       ('Маврин Павел');
#+end_src

#+RESULTS:
| INSERT 0 3 |
|------------|

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
INSERT INTO Courses (Name) VALUES
       ('Матанализ'),
       ('Базы Данных'),
       ('АиСД');
#+end_src

#+RESULTS:
| INSERT 0 3 |
|------------|


#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
SELECT (Id, NAME) FROM Students;
#+end_src

#+RESULTS:
| row                         |
|-----------------------------|
| (1,"Иванов Иван")           |
| (2,"Петров Петр")           |
| (3,"Казимиров Казимир")     |
| (4,"Игнатьев Игнат")        |
| (5,"Тимуров Тимур")         |
| (6,"Станиславов Станислав") |

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
SELECT (Id, NAME) FROM Groups;
#+end_src

#+RESULTS:
| row        |
|------------|
| (1,M33371) |
| (2,M3133)  |
| (3,M34391) |

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
SELECT (Id, NAME) FROM Lecturers;
#+end_src

#+RESULTS:
| row                     |
|-------------------------|
| (1,"Корнеев Георгий")   |
| (2,"Кохась Константин") |
| (3,"Маврин Павел")      |

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
SELECT (Id, NAME) FROM Courses;
#+end_src

#+RESULTS:
| row               |
|-------------------|
| (1,Матанализ)     |
| (2,"Базы Данных") |
| (3,АиСД)          |

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
INSERT INTO StudentGroups (StudentId, GroupId) VALUES
       (1, 1),
       (4, 2),
       (3, 1),
       (6, 3);
#+end_src

#+RESULTS:
| INSERT 0 4 |
|------------|

#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
INSERT INTO Teachers (CourseId, GroupId, LecturerId) VALUES
       (1, 2, 2),
       (1, 1, 2),
       (2, 1, 3),
       (3, 1, 3),
       (3, 2, 3);
#+end_src

#+RESULTS:
| INSERT 0 5 |
|------------|


#+header: :engine postgres
#+header: :database hw4
#+begin_src sql
INSERT INTO Marks (CourseId, StudentId, Mark) VALUES
       (1, 1, 2),
       (1, 3, 5),
       (2, 6, 1),
       (3, 2, 10);
#+end_src

#+RESULTS:
| INSERT 0 4 |
|------------|
