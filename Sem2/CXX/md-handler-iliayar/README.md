Введение
--------

Электронные биржи предоставляют котировки цен в режиме реального времени.
Каждое событие на рынке, такое как новый заказ, изменение цены, и т.п., передаются как отдельные сообщения.
Эти сообщения распространяется подписчикам обычно через UDP (User Datagram Protocol).
Биржа использует некий протокол для упаковки событий в пакеты (UDP packets). Такие пакеты содержат обычно две
части: заголовок и тело пакета. В заголовке пакета содержится сервисная информация, которая описывает сам пакет и тело.
Например, в заголовке указывается размер всего пакета, включая его тело, последовательный номер сообщения
и число сообщений в пакете, которые следуют сразу за заголовком.


Заголовок пакета

----------------------------------------------
| 2 bytes   | 4 bytes | 1 byte    | 1 byte   |
----------------------------------------------
| Packet Sz | Seq Num | Msd Count | Not used |
----------------------------------------------

Тело пакета, если присутсвует, представляет собой одно или несколько сообщений, закодированных
согласно правилам протокола биржы. В контексте этой задачи, мы будем рассматривать только заголовки пакета.


Обработка пакетов и воссоздание корректного состояния рынка биржы полностью ложится на подписчика данных.
Программа подписчика должна обрабатывать пакеты согласно строгой последовательной нумерации сообщений,
отфильтровывать дубликаты и восстанавливать утраченные сообщения.

Передача данных
---------------
Передача данных используя UDP легко масштабируется для многих подписчиков, но не представляется надежной.
Пакеты могут быть потеряны или прийти в случайном порядке. Например, пакет с сообщением под номером 10,
может прийти раньше чем пакет с сообщением под номером 9. А пакет с сообщением под номером 8 может быть потерян.
По этой причине, биржы передают данные по двум каналам первичному (primary) и вторичному (secondary or redundand).
Два канала увеличивает надежность передачи данных, но привносят свои сложности. Теперь, подписчик может получить
пакет с сообщением под номером 10 дважды. Так же возможно ситуация, когда один из каналов присылает пакеты с
небольшой задержкой. Например, подписчик может получить пакеты с сообщеними под номерами 8, 9 и 10, и через некоторое
время получить эти пакеты снова через другой канал, но не обязательно в той же последовательности. Как было указано
выше, заголовок пакета указывает количество сообщений в данном пакете. Каналы передачи данных могут по-разному
паковать сообщения. Например, первичный канал упакует сообщения 8, 9 и 10 вместе, в то время вторичный
канал упакует сообщения 9, 10 и 11 в один пакет. Если же пакет был утрачен в режиме реального времени,
то утерянные сообщения следует запросить через сервис восстановления сообщений (relay or recovery). При этом, сервис
восстановления сообщений, может упаковать сообщения отлично от того, как пакеты упаковываются каналами
реального времени.

Каналы реального времени могут посылать пакеты, которые содержат в себе heartbeat сообщение. В таких пакетах,
число сообщений равно нулю. А последовательный номер в пакете, указывает либо на номер последнего сообщения,
которое уже было выслано, либо на номер соощения, которое будет выслано. Таким образом, программа может
отслеживать полученные сообщения. В контексте данной задачи, heartbeat сообщения будут содержать
номер последнего сообщение, которое уже было выслано.


Задача
------
Реализовать интерфейс обработки пакетов данных, получаемых через два канала.
Сообщения в пакетах должны быть упорядочны согласно их последовательным номерам, дубликаты отброшены,
и утраченные сообщения восстановлены. По мере получения сообщений в последовательном порядке,
вызывать функцию `IServce::handle_message`, которая будет имитировать обработку сообщений.
Нумерация сообщений начинается с 1.


Интерфейс для реализации:

```c++
class MdHandler
{
    void handle_packet(const Packet & packet);
    void handle_resend(const Packet & packet);
}
```

Функция `void handle_packet(const Packet & packet)` вызывается каждый раз, когда новый пакет из сети был принят программой.
Пакет (`Packet`), может быть прислан из любого канала.
Функция не thread-safe и после возврата из функции, объект `Packet` может быть удален.


Функция `void handle_resend(const Packet & packet)` вызывается на каждый вновь запрощенный пакет через сервис
восставновления пакетов.
Функция не thread-safe и после возврата из функции, объект `Packet` может быть удален.

Вспомогательный интерфейс:

```c++
class IService
{
    void resend_messages(uint32_t start_seq_num, uint16_t msg_count);
    void handle_message(uint32_t seq_num);
}
```

Для восставновления потерянных пакетов, следуют вызывать следующую функцию:

```c++
void resend_messages(uint32_t start_seq_num, uint16_t msg_count);
```

где
* `start_seq_num` - последовательный номер сообщений, который требуется для восстановления
* `msg_count` - общее число соощений, начиная с `start_seq_num`.


По мере получения сообщений согласно последотельной нумерации, надо вызывать функцию

```c++
void handle_message(uint32_t seq_num);
```

где
* `seq_num` - последовательный номер сообщений


Пример решения
--------------

A. Первый полученный пакет: `Packet (3, 1)`

1. Сообщения с номерами 1-2 были утрачены, сообщение с номером 3 сохраняется в памяти.

2. Запрашивается пакет с номероми 1-2 (`IService::resend_messages(1, 2)`)

3. Функция `handle_resend()` будет вызвана один или два раза, с потерянными пакетами. Предположим,
    что сервис восстановления сообщений вернул один пакет с двума сообещения `Packet(1, 2)`. Мы восстановили
    все сообщения.

4. Теперь можно вызывать функцию `IService::handle_message()` последовательно с номерами 1, 2, 3.

B. `Packet(3, 0)`

1. Это сообщение heartbeat, так как число сообщений в нем равно 0. `seq_num=3` указывает
   на номер последнего сообщения. Этот пакет можно проигнорировать, так как мы уже обработали 3 сообщения.

C. `Packet(3, 2)`

1. Пришел пакет, в котором содержатся сообщения 3 и 4. Сообщение 3 мы уже обработали и отбрасываем.
   Сообщение 4 посылаем на обработку. `IService::handle_message(4)`.

D. `Packet(5, 0)`

1. Это сообщение heartbeat, и оно указывает на то, что последнее сообщение было 5, но мы обработали только 4.
   Это указывает, на то, что сообщение с номером 5 было утрачего.

2. Вызываем функцию восстановлений сообщений, `IService::resend_messages(5, 1)`.

3. По получении сообщения через функцию `handle_resend`. Вызываем функцию обработки сообщений `IService::handle_message(5)`.

