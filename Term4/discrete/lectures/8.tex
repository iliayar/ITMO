% Created 2021-04-14 Wed 16:54
% Intended LaTeX compiler: pdflatex

\documentclass[english]{article}
\usepackage[T1, T2A]{fontenc}
\usepackage[lutf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{natbib}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{grffile}
\usepackage{extarrows}
\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{lipsum}
\usepackage{rotating}
\usepackage{placeins}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{capt-of}

\usepackage{geometry}
\geometry{a4paper,left=2.5cm,top=2cm,right=2.5cm,bottom=2cm,marginparsep=7pt, marginparwidth=.6in}
 \usepackage{hyperref}
 \hypersetup{
     colorlinks=true,
     linkcolor=blue,
     filecolor=orange,
     citecolor=black,      
     urlcolor=cyan,
     }

\usetikzlibrary{decorations.markings}
\usetikzlibrary{cd}
\usetikzlibrary{patterns}
\usetikzlibrary{automata, arrows}

\newcommand\addtag{\refstepcounter{equation}\tag{\theequation}}
\newcommand{\eqrefoffset}[1]{\addtocounter{equation}{-#1}(\arabic{equation}\addtocounter{equation}{#1})}
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}


\newcommand{\R}{\mathbb{R}}
\renewcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\A}{\mathfrak{A}}
\newcommand{\B}{\mathfrak{B}}
\newcommand{\rank}{\mathop{\rm rank}\nolimits}
\newcommand{\const}{\var{const}}
\newcommand{\grad}{\mathop{\rm grad}\nolimits}

\newcommand{\todo}{{\color{red}\fbox{\text{Доделать}}}}
\newcommand{\fixme}{{\color{red}\fbox{\text{Исправить}}}}

\newcounter{propertycnt}
\setcounter{propertycnt}{1}
\newcommand{\beginproperty}{\setcounter{propertycnt}{1}}

\theoremstyle{plain}
\newtheorem{propertyinner}{Свойство}
\newenvironment{property}{
  \renewcommand\thepropertyinner{\arabic{propertycnt}}
  \propertyinner
}{\endpropertyinner\stepcounter{propertycnt}}
\newtheorem{axiom}{Аксиома}
\newtheorem{lemma}{Лемма}
\newtheorem{manuallemmainner}{Лемма}
\newenvironment{manuallemma}[1]{%
  \renewcommand\themanuallemmainner{#1}%
  \manuallemmainner
}{\endmanuallemmainner}

\theoremstyle{remark}
\newtheorem*{remark}{Примечание}
\newtheorem*{solution}{Решение}
\newtheorem{corollary}{Следствие}[theorem]
\newtheorem*{examp}{Пример}
\newtheorem*{observation}{Наблюдение}

\theoremstyle{definition}
\newtheorem{task}{Задача}
\newtheorem{theorem}{Теорема}[section]
\newtheorem*{definition}{Определение}
\newtheorem*{symb}{Обозначение}
\newtheorem{manualtheoreminner}{Теорема}
\newenvironment{manualtheorem}[1]{%
  \renewcommand\themanualtheoreminner{#1}%
  \manualtheoreminner
}{\endmanualtheoreminner}
\captionsetup{justification=centering,margin=2cm}
\newenvironment{colored}[1]{\color{#1}}{}

\tikzset{->-/.style={decoration={
  markings,
  mark=at position .5 with {\arrow{>}}},postaction={decorate}}}
\makeatletter
\newcommand*{\relrelbarsep}{.386ex}
\newcommand*{\relrelbar}{%
  \mathrel{%
    \mathpalette\@relrelbar\relrelbarsep
  }%
}
\newcommand*{\@relrelbar}[2]{%
  \raise#2\hbox to 0pt{$\m@th#1\relbar$\hss}%
  \lower#2\hbox{$\m@th#1\relbar$}%
}
\providecommand*{\rightrightarrowsfill@}{%
  \arrowfill@\relrelbar\relrelbar\rightrightarrows
}
\providecommand*{\leftleftarrowsfill@}{%
  \arrowfill@\leftleftarrows\relrelbar\relrelbar
}
\providecommand*{\xrightrightarrows}[2][]{%
  \ext@arrow 0359\rightrightarrowsfill@{#1}{#2}%
}
\providecommand*{\xleftleftarrows}[2][]{%
  \ext@arrow 3095\leftleftarrowsfill@{#1}{#2}%
}
\makeatother

\newenvironment{rualgo}[1][]
  {\begin{algorithm}[#1]
     \selectlanguage{russian}%
     \floatname{algorithm}{Алгоритм}%
     \renewcommand{\algorithmicif}{{\color{red}\textbf{если}}}%
     \renewcommand{\algorithmicthen}{{\color{red}\textbf{тогда}}}%
     \renewcommand{\algorithmicelse}{{\color{red}\textbf{иначе}}}%
     \renewcommand{\algorithmicend}{{\color{red}\textbf{конец}}}%
     \renewcommand{\algorithmicfor}{{\color{red}\textbf{для}}}%
     \renewcommand{\algorithmicto}{{\color{red}\textbf{до}}}%
     \renewcommand{\algorithmicdo}{{\color{red}\textbf{делать}}}%
     \renewcommand{\algorithmicwhile}{{\color{red}\textbf{пока}}}%
     \renewcommand{\algorithmicrepeat}{{\color{red}\textbf{повторять}}}%
     \renewcommand{\algorithmicuntil}{{\color{red}\textbf{до тех пор пока}}}%
     \renewcommand{\algorithmicloop}{{\color{red}\textbf{повторять}}}%
     \renewcommand{\algorithmicnot}{{\color{blue}\textbf{не}}}%
     \renewcommand{\algorithmicand}{{\color{blue}\textbf{и}}}%
     \renewcommand{\algorithmicor}{{\color{blue}\textbf{или}}}%
     \renewcommand{\algorithmicrequire}{{\color{blue}\textbf{Предусловие}}}%
     \renewcommand{\algorithmicrensure}{{\color{blue}\textbf{Постусловие}}}%
     \renewcommand{\algorithmicrtrue}{{\color{blue}\textbf{истинна}}}%
     \renewcommand{\algorithmicrfalse}{{\color{blue}\textbf{ложь}}}%
     % Set other language requirements
  }
  {\end{algorithm}}
\author{Ilya Yaroshevskiy}
\date{\today}
\title{Лекция 8}
\hypersetup{
 pdfauthor={Ilya Yaroshevskiy},
 pdftitle={Лекция 8},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.50 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Теория вычислимости}
\label{sec:org3dc9915}
\(\Sigma\) --- алфавит, \(\Sigma^* = \bigcup_{k = 0}^\infty \Sigma^k\). \(L \subset \Sigma^*\) --- формальный язык.
\begin{definition}
\(L\) --- \textbf{разрешимый (рекурсивный)}, если \(\exists\) программа \(P\), такая что:
\begin{itemize}
\item \(x \in L \implies P(x) = 1\)
\item \(x \not\in L \implies P(x) = 0\)
\end{itemize}
\end{definition}
\begin{remark}
Раньше называли рекурсивным, так как использовали рекурсивные функции. Это определение появилось до языков программирования
\end{remark}
\begin{remark}
Множетво разрешимых языков счетно
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn p(x: Word) -> Res {
    loop { }
    return 1;
}
\end{minted}
\end{remark}
\begin{remark}
Любой конечный язык является разрешимым
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn p(x: Word) -> Res {
    if x == x_1 { // $x_1 \in L$
	return 1; 
    }
    if x == x_2 { // $x_2 \in \L$
	return 1;
    }
    // $\dots$
}
\end{minted}
\end{remark}
\begin{definition}
\(L\) --- \textbf{полуразрешимый (перечислимый, рекурсивно перечислмый)}, если \(\exists p\), такая что:
\begin{enumerate}
\item \(x \in L \implies p(x) = 1\)
\item \(x \not\in L \implies p(x) \neq 1\)
\end{enumerate}
\end{definition}
\begin{remark}
Множество полуразрешимых языков счетно
\end{remark}
\begin{remark}
Разрешимый \(\implies\) Полуразрешимый
\end{remark}
\begin{remark}
\(\Sigma^*\), \(\N^+\), \(\var{Prog}\) --- будут для нас эквивалентными понятиями, когда будем говорить про формальный язык.
\begin{itemize}
\item \(\Sigma^* \leftrightarrow \var{Prog}\) --- те строки, которые не являются программами, будем считать программами, которые `зависают` на любом входе
\item \(\Sigma^* \leftrightarrow \N^+\) --- занумеруем строки в градуированном лексикографичеком порядке \\
\[ \varepsilon, `0`, `1`, `00`, `01`, `10`, `11`, `000`, `001` \]
\end{itemize}
\end{remark}
\begin{definition}
Арифметические операции, \texttt{if}, \texttt{for}, \texttt{while}, вызов функций. \(p\) --- программа, \(x\) --- слово --- запустить программу \(p\) на слове \(x\), запустить программу \(p\) на слове \(x\) с ограничением на время \(\var{TL} = t\), и ограничением на память \(\var{ML} = m\)
\end{definition}
\begin{definition}
\(L\) --- перечислимый, если \(\exists p\) которая на пустом входе выводит любое слово из языка хотя бы один раз. \(\forall x \in L\ \exists t(x)\quad P\big|_{\var{TL} = t}\) выводит \(x\)
\end{definition}
\begin{examp}
\-
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn zeroes() {
    for i in [0..] {
	let s = '0' * i;
	println!("{}", s)
    }
}
\end{minted}
\end{examp}
\begin{theorem}
\(L\) --- перечислимый \(\Leftrightarrow\) \(L\) --- полуразрешимый
\end{theorem}
\begin{proof}
\-
\begin{description}
\item[{\((\Rightarrow)\)}] Пусть \texttt{listL()} --- перечисляет \(L\)
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn inL(x: Word) -> Res {
    async { listL(); }
    if x.is_printed() {
	return 1;
    }
    return 0;
}
\end{minted}
\item[{\((\Leftarrow)\)}] \texttt{inL()} --- полуразрешиель \(L\). Если напишем \texttt{listL()}, то он зависнет. Введем таймер.
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn listL() -> Res {
    for t in [0..] {
	for x in sigma[0..t] {
	    if inL(x).await(t) {
		println!("{}", x)
	    }
	}
    }
}
\end{minted}
\end{description}
\end{proof}
\begin{remark}
Кодировать пару \(\langle x, y \rangle\) можем
\end{remark}
\begin{definition}
\textbf{Универсальный язык}:
\[ U = \{\langle p, x \rangle \big| \text{программа } p(x) = 1\} \]
\end{definition}
\beginproperty
\begin{property}
\(U\) --- полуразрешим --- Тьюринг полный
\end{property}
\begin{theorem}
\(U\) --- не разрешим
\end{theorem}
\begin{proof}
Допустим существует программа \texttt{rust\#inU((p, x): (Word, Word))}, которая разрешает \(U\)
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn q(x: Word) -> Res {
    if inU((x, x)) {
	return 0;
    } else {
	return 1;
    }
}
\end{minted}
\texttt{q} никогда не зависает. Вызовем \texttt{q(q)}
\begin{itemize}
\item \(inU(\langle q, q \rangle) = 1\)
\begin{itemize}
\item \(q(q) = 0\)
\item \(\langle q, q \rangle \in U \implies q(q) = 1\)
\end{itemize}
\item \(inU(\langle q, q\rangle) = 0\)
\begin{itemize}
\item \(\langle q, q \rangle \not\in U \implies q(q) \neq 1\)
\item \(q(q) = 1\)
\end{itemize}
\end{itemize}
Получается, что \(q\) не возвращает ни 0 ни 1. Противоречие
\end{proof}
\beginproperty
\begin{property}
\(A, B\) разрешимы, \(A \cup B\) --- разрешим
\end{property}
\begin{property}
\(A, B\) разрешимы, \(A \cap B\) --- резрешим
\end{property}
\begin{property}
\(A\) --- разрешим, \(\overline{A} = \Sigma^* \setminus A\) --- разрешим
\end{property}
\begin{property}
\(A, B\) полуразрешимы, \(A \cap B\) --- разрешим
\end{property}
\begin{property}
\(A, B\) полуразрешимы, \(A \cup B\) --- разрешим
\end{property}
\begin{proof}
\-
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn p() -> Res {
    for i in [0..] {
	if inA.await(t) {
	    return 1;
	}
	if inB.await(t) {
	    return 1;
	}
    }
}
\end{minted}
\end{proof}
\begin{theorem}[Поста]
\(L\) и \(\overline{L}\) оба полуразрешимы \implies \(L\) --- разрешим
\end{theorem}
\begin{proof}
\-
\begin{minted}[frame=lines,linenos=true,mathescape]{rust}
fn inL(x: Word) -> Res {
    for t in [0..] {
	if inL(x).await(t) {
	    return 1;
	}
	if inCL(x).await(t) { // $\text{\rm CL} = \overline{L}$
	    return 0;
	}
    }
}
\end{minted}
\end{proof}
\begin{theorem}
Не существует языка программирования, который поддерживает все три свойства
\begin{enumerate}
\item Программа не зависает
\item Любой разрешимый язык, распознается программой на этом языке
\item Функция \(\langle p, x \rangle \mapsto p(x)\) вычислима
\end{enumerate}
\end{theorem}
\end{document}
