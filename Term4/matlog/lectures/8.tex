% Created 2021-04-09 Fri 15:08
% Intended LaTeX compiler: pdflatex

  \documentclass[english]{article}
  \usepackage[T1, T2A]{fontenc}
\usepackage[lutf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{natbib}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{grffile}
\usepackage{extarrows}
\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{lipsum}
\usepackage{rotating}
\usepackage{placeins}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{capt-of}
  
  \usepackage{geometry}
  \geometry{a4paper,left=2.5cm,top=2cm,right=2.5cm,bottom=2cm,marginparsep=7pt, marginparwidth=.6in}
   \usepackage{hyperref}
 \hypersetup{
     colorlinks=true,
     linkcolor=blue,
     filecolor=orange,
     citecolor=black,      
     urlcolor=cyan,
     }

\usetikzlibrary{decorations.markings}
\usetikzlibrary{cd}
\usetikzlibrary{patterns}
\usetikzlibrary{automata, arrows}

\newcommand\addtag{\refstepcounter{equation}\tag{\theequation}}
\newcommand{\eqrefoffset}[1]{\addtocounter{equation}{-#1}(\arabic{equation}\addtocounter{equation}{#1})}
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}


\newcommand{\R}{\mathbb{R}}
\renewcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\A}{\mathfrak{A}}
\newcommand{\rank}{\mathop{\rm rank}\nolimits}
\newcommand{\const}{\var{const}}
\newcommand{\grad}{\mathop{\rm grad}\nolimits}

\newcommand{\todo}{{\color{red}\fbox{\text{Доделать}}}}
\newcommand{\fixme}{{\color{red}\fbox{\text{Исправить}}}}

\newcounter{propertycnt}
\setcounter{propertycnt}{1}
\newcommand{\beginproperty}{\setcounter{propertycnt}{1}}

\theoremstyle{plain}
\newtheorem{propertyinner}{Свойство}
\newenvironment{property}{
  \renewcommand\thepropertyinner{\arabic{propertycnt}}
  \propertyinner
}{\endpropertyinner\stepcounter{propertycnt}}
\newtheorem{axiom}{Аксиома}
\newtheorem{lemma}{Лемма}
\newtheorem{manuallemmainner}{Лемма}
\newenvironment{manuallemma}[1]{%
  \renewcommand\themanuallemmainner{#1}%
  \manuallemmainner
}{\endmanuallemmainner}

\theoremstyle{remark}
\newtheorem*{remark}{Примечание}
\newtheorem*{solution}{Решение}
\newtheorem{corollary}{Следствие}[theorem]
\newtheorem*{examp}{Пример}
\newtheorem*{observation}{Наблюдение}

\theoremstyle{definition}
\newtheorem{task}{Задача}
\newtheorem{theorem}{Теорема}[section]
\newtheorem*{definition}{Определение}
\newtheorem*{symb}{Обозначение}
\newtheorem{manualtheoreminner}{Теорема}
\newenvironment{manualtheorem}[1]{%
  \renewcommand\themanualtheoreminner{#1}%
  \manualtheoreminner
}{\endmanualtheoreminner}
\captionsetup{justification=centering,margin=2cm}
\newenvironment{colored}[1]{\color{#1}}{}

\tikzset{->-/.style={decoration={
  markings,
  mark=at position .5 with {\arrow{>}}},postaction={decorate}}}
\makeatletter
\newcommand*{\relrelbarsep}{.386ex}
\newcommand*{\relrelbar}{%
  \mathrel{%
    \mathpalette\@relrelbar\relrelbarsep
  }%
}
\newcommand*{\@relrelbar}[2]{%
  \raise#2\hbox to 0pt{$\m@th#1\relbar$\hss}%
  \lower#2\hbox{$\m@th#1\relbar$}%
}
\providecommand*{\rightrightarrowsfill@}{%
  \arrowfill@\relrelbar\relrelbar\rightrightarrows
}
\providecommand*{\leftleftarrowsfill@}{%
  \arrowfill@\leftleftarrows\relrelbar\relrelbar
}
\providecommand*{\xrightrightarrows}[2][]{%
  \ext@arrow 0359\rightrightarrowsfill@{#1}{#2}%
}
\providecommand*{\xleftleftarrows}[2][]{%
  \ext@arrow 3095\leftleftarrowsfill@{#1}{#2}%
}
\makeatother

\newenvironment{rualgo}[1][]
  {\begin{algorithm}[#1]
     \selectlanguage{russian}%
     \floatname{algorithm}{Алгоритм}%
     \renewcommand{\algorithmicif}{{\color{red}\textbf{если}}}%
     \renewcommand{\algorithmicthen}{{\color{red}\textbf{тогда}}}%
     \renewcommand{\algorithmicelse}{{\color{red}\textbf{иначе}}}%
     \renewcommand{\algorithmicend}{{\color{red}\textbf{конец}}}%
     \renewcommand{\algorithmicfor}{{\color{red}\textbf{для}}}%
     \renewcommand{\algorithmicto}{{\color{red}\textbf{до}}}%
     \renewcommand{\algorithmicdo}{{\color{red}\textbf{делать}}}%
     \renewcommand{\algorithmicwhile}{{\color{red}\textbf{пока}}}%
     \renewcommand{\algorithmicrepeat}{{\color{red}\textbf{повторять}}}%
     \renewcommand{\algorithmicuntil}{{\color{red}\textbf{до тех пор пока}}}%
     \renewcommand{\algorithmicloop}{{\color{red}\textbf{повторять}}}%
     \renewcommand{\algorithmicnot}{{\color{blue}\textbf{не}}}%
     \renewcommand{\algorithmicand}{{\color{blue}\textbf{и}}}%
     \renewcommand{\algorithmicor}{{\color{blue}\textbf{или}}}%
     \renewcommand{\algorithmicrequire}{{\color{blue}\textbf{Предусловие}}}%
     \renewcommand{\algorithmicrensure}{{\color{blue}\textbf{Постусловие}}}%
     \renewcommand{\algorithmicrtrue}{{\color{blue}\textbf{истинна}}}%
     \renewcommand{\algorithmicrfalse}{{\color{blue}\textbf{ложь}}}%
     % Set other language requirements
  }
  {\end{algorithm}}
\author{Ilya Yaroshevskiy}
\date{\today}
\title{Лекция 8}
\hypersetup{
 pdfauthor={Ilya Yaroshevskiy},
 pdftitle={Лекция 8},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.50 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Исчесление предиктов}
\label{sec:orgf3ef73a}
\begin{theorem}[Геделя о полноте ИП]
У любого н.м.з.ф. (непротиворечивого множества замкнутых формул) ИП существует модель
\end{theorem}
\begin{theorem}
Если формула \(\phi\) --- замкнутая формула ИП \\
\uline{Тогда} найдется \(\psi\) --- замкнутая формула ИП, что \(\vdash \varphi \to \psi\) и \(\psi \to \varphi\). \(\psi\) --- с поверхностными кванторами
\end{theorem}
\begin{proof}
См. ДЗ
\end{proof}
\begin{remark}
Рассмотрим \(\Gamma\) --- н.м.з.ф. --- рассмотрим \(\Gamma'\) --- полное расширение \(\Gamma\). Пусть \(\varphi\) --- фомула из \(\Gamma'\), тогда найдется \(\psi in \Gamma'\), что \(\psi\) --- с поверхностными кванторами и \(\vdash \varphi \to \psi\), \(\vdash \psi \to \varphi\)
\end{remark}
\begin{proof}[Доказательство теоремы Геделя о полноте ИП]
Рассмотрим множество констант(нуль местных функциональных символов) --- \(d^i_j\). Построим \(\{\Gamma_j\}:\)
\[ \Gamma' = \Gamma_0 \subseteq \Gamma_1 \subseteq \Gamma2 \subseteq \dots \subseteq \Gamma_j \subseteq \dots \]
Переход \(\Gamma_j \Rightarrow \Gamma_{j + 1}\): рассмторим все формулы из \(\Gamma_j\): \(\{\gamma_1, \gamma_2, \gamma_3, \dots\}\)
\begin{enumerate}
\item \(\gamma_i\) ---  формула без кванторов --- оставим на месте
\item \(\gamma_i \equiv \forall x.\varphi\) --- добваим к \(\Gamma_{j + 1}\) все формулы вида \(\varphi[x:=\Theta]\), где \(\Theta\) --- составлен из всех ф.с. ИП и констант вида \(d_1^k,\dots,d^k_j\)
\item \(\gamma_i \equiv \exists x.\varphi\) --- добавим одну формулу --- \(\varphi[x:=d^i_{j + 1}]\)
\end{enumerate}


\begin{description}
\item[{\textbf{Утв. 1}}] \(Gamma_{i + 1}\) непр., если \(\Gamma_i\) --- непр. \\
Докажем от противного. \(\Gamma_{i + 1} \vdash \beta \& \neg \beta\)
\[ \Gamma_i, \gamma_1, \dots, \gamma_n \vdash \beta \& \neg \beta \quad \gamma_i \in \Gamma_{i + 1} \setminus \Gamma_i \]
\[ \Gamma_i \vdash \gamma_1 \to \gamma_2 \to \dots \to \gamma_n \to \beta \& \neg \beta \]
\(\gamma_i\) --- замкнутое \(\implies\) т. о дедукции. Докажем что \(\Gamma_i \vdash \beta \& \neg \beta\) по индукции.
\[ \Gamma_i \vdash \gamma \to \varepsilon \]
Покажем \(\Gamma_i \vdash \varepsilon\), т.е. \(\gamma\) получен из \(\forall x. \xi\) или \(\forall x. \xi\) \(\in \Gamma_i\)
\begin{description}
\item[{\textbf{\((\forall x. \xi)\)}}] Заметим, что \(\Gamma_i \vdash \forall x.\xi\)
\[ \begin{array}{ll}
    \vdots & \text{по условию} \\
    \gamma \to \varepsilon & \text{по построению }\Gamma_{i + 1} \\
    \forall x.\xi \to (\underbrace{\xi[x:=\Theta]}_\gamma) & \text{(акс. 11)} \\
    (\forall x.\xi) \to \varepsilon & \left|\begin{matrix} \eta \to \xi \\ \xi \to \kappa \end{matrix}\right. \implies \eta \to \kappa\\
    \forall x.\xi & \\
    \varepsilon & \text{(M.P.)}
    \end{array} \]
\item[{\textbf{\((\exists x. \xi)\)}}] \[ \Gamma_i \vdash \overbrace{\xi[x:=d^k_{i + 1}]}^\gamma \to \varepsilon \]
Заметим, что \(d^k_{i + 1}\) не входит в \(\varepsilon\). Заменим все \(d^k_{i + 1}\) в доказательстве на \(y\) --- новая перменная
\[ \Gamma_i \vdash \xi[x:=y] \to \varepsilon \]
\[ \begin{array}{ll}
    \exists y. \xi[x:=y] \to \varepsilon & \\
    (\exists x. \xi x) \to (\exists t. \xi[x:=y]) & \\
    (\exists x.\xi) \to \varepsilon & \\
    \exists x. \xi & \\
    \varespilon & 
    \end{array}\]
\[ \fixme \]
\end{description}
\item[{\textbf{Утв. 2}}] \(\Gamma^*\) --- непр. \(\Gamma_0 \vdash \gamma_1 \to \dots \to \gamma_n \to \beta \& \neg \beta\)
\[ \Gamma_{\max_i(0..n)} \vdash \beta \& \neg \beta \]
Значит \(\Gamma_\max\) --- противоречиво, \(\Gamma^\triangle = \Gamma^*\) без кванторов \\
\uline{Значит} у \(\Gamma^\triangle\) есть модель \(M\)
\item[{\textbf{Утв. 3}}] \(\gamma \in \Gamma'\), то \(\llb \gamma \rrb_M = \text{И}\) \\
Индукция по количеству кванторов в \(\gamma\). Рассмторим:
\begin{enumerate}
\item \(\gamma \equiv \forall x. \delta\) \\
\(\llb \forall x. \delta \rrb\), если \(\llb \delta \rrb^{x := \kappa} = \text{И}, \kappa \in D\). Рассмотри \(\llb \delta \rrb^{x := \kappa},\ k \in D\). \(\kappa\) содержит константы и ф-с, \(\kappa\) осмысленно \(\Gamma_p\). \(\delta\) добавлена на шаге \(q\). Рассмотрим шаг \(\Gamma_{\max(p, q)}\) \(\forall x. \delta: \Gamma_{\max(p, q) + 1}\) добавлена \(\delta[x:=\kappa]\). \(\delta[x:=\kappa]\) --- меньше на 1 квантор, \(\llb \delta[x:=k] \rrb = \text{И}\)
\item \(\gamma \equiv \exists x. \delta\) --- аналогично
\end{enumerate}
\end{description}
\end{proof}

\begin{theorem}
ИП неразрешимо
\end{theorem}
\begin{definition}
\textbf{Язык} --- множество слов. Язык \(\mathcal{L}\) разрешим, если существует \(A\) --- алгоритм, что по слову \(w\): \\
\(A(w)\) --- останавливается в `1`, если \(w \in \mathcal{L}\) и `0`, если \(w \not\in \mathcal{L}\)
\end{definition}
\begin{remark}
Проблема останова: не существует алгоритма, который по программе для машина Тьюринга ответит, остановится она или нет. \\
Пусть \(\mathcal{L}'\) --- язык всех останов программы для машины Тьюринга. \(\mathcal{L}'\) неразрешим
\end{remark}
\begin{remark}
\texttt{[a, b, c, d, e] = cons(a, cons(b, cons(c, cons(d, cons(e, nil)))))} \\
\(A\) --- алфавит ленты
\[ \left.\begin{array}{l}
S_x,\ x \in A \\
e \text{ --- } \text{nil}
\end{array}\right\} \text{ --- } 0\text{-местные функциональные символы}\]
\[ C(a, b) \text{ --- } 2\text{-местные функциональные символы} \]
\(b_s, s \in \mathcal{S}\) --- множество всех состояний, \(b_0\) --- начальное состояние.
\[ C(s_c, C(s_b, C(s_a, e))) \quad C(s_d, C(s_e, e)) \]
Заведем предикат, которых отвечает было ли состояние в процессе. Начальное состояние --- машина Тьюринга запущена на строке \(\alpha\):
\[ R(\alpha, e, b_0) \]
Переход:
\[ (s_x, b_s) \to (s_y, b_t, \leftrightarrow) \]
\[ (s_x, b_s) \to (s_y, b_t, \leftarrow) \]
Если пермещение законно, то можем построить для каждого такие правила:
\[ \forall z. \forall w. R(C(s_x, z), w, b_s) \to R(C(s_y, z), w, b_t) \]
\[ \dots  R(z, C(s_y, w), b_t)\]
Сделаем коньюнкцию вех эти правил: \(R(\dots)\&R(\dots)\&\dots\&R(\dots) \to \exists z. \exists . R(z, w, b_\triangle)\)
\fixme
\end{remark}
\begin{examp}
\-
\begin{enumerate}
\item \(R(C(s_k, e), e, b_0)\) --- доказуемо(мы так сказали)
Двинем голвку вправо:
\[ \forall x. \forall y. R(C(s_k, x), y, b_0) \to R(x, C(s_k, y), b_1) \]
\end{enumerate}
\end{examp}
\end{document}
