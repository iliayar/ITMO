#import "../../../other/typst/lecture_mse.typ": *

#show: doc => lecture(
  subj: [Алгоритмы и структуры данных],
  title: [Лекция 10],
  date: [26 ноября],
  number: 10,
  doc
)

= Минимальные остовные деревья (MST)

У каждого ребра есть вес. Нужно выбрать ребра, которые образуют дерево и имеют суммарные минимальный вес.

== Алгоритм Прима

Возьмем ребро с минимальным весом, добавим его в дерево. Возьмем минимальные ребро $e$ их тех, что имеют конец в вершине, которая уже в дереве $A$.

#statement()[
  $exists  T : e in T$, где $T$ -- MST
]

#pseudocode-list()[
- *while* $A != V$
  - Взять минимальное по весу $e$, имеющее конец в вершине в $A$
]

#proof()[
  Рассмотрим $T$. Пусть $e in.not T$. Если добавим в $T$ ребро $e$, получим цикл. Ребро $e$ торчит из $A$ в $V \\ A$. Значит есть другое ребро $e'$, соединяющее $A$ и $V \\ A$. Т.е. есть другое дерево $T \\ {e'} union {e}$ которое не хуже.
]

#pseudocode-list(title: "Алгоритм Прима")[
- $A <- {1}$
- $x <- 1$
- *for* $n - 1$
  - *for* $e in x -> v$
    - Улучшить $"minW"_v$ до $w_e$
  - Выбрать $x in.not A: "minW"_x = min$
]

Используем кучу для получения минимума.

== Алгоритм Краскала

1. Отсортируем ребра по возрастанию веса
2. Будем жадно брать: если не образуется цикл

Нужно уметь быстро определять компоненту связности по вершине (из текущего остова).

#pseudocode-list()[
- *for* $e = a -> b$
  - *if* $"Comp"(a) != "Comp"(b)$
    - $"Add"(e)$
]

#proof()[#todo()]

= СНМ (DSU -- Disjoint Set Union)

== На списках

Для каждой вершины храним номер множества в котором она находится, а также для каждого множества храним список вершин.
- $"get"(a)$ -- просто берем из списка номер множества $O(1)$
- $"join"(a, b)$ -- перекрашиваем меньшее из множест: перекидываем все вершины, обновляем номер множества для вершин. В сумме за $O(n log n)$.

#proof[Для каждой вершины при перекидывании, размер множества в котором она находится увеличивается минимум вдвое. Значит для каждой вершины количество перекидываний не больше $log n$]

== На деревьях

Храним родителя для каждой вершины $v$ в $p_v$.
- $"get"$ -- поднимаемся до корня дерева
- $"join"$ -- поднимаемся в обоих деревьях до корня, подвешиваем меньшее к большему

Эвристики:
#pseudocode-list(title: "join(a, b)")[
- $a <- "get"(a)$
- $b <- "get"(b)$
- *if* $"size"_a > "size"_b$
  - $"swap"(a, b)$
- $p_a <- b$
- $"size"_b <- "size"_b + "size"_a$
]

#statement[
  Высота дерева $h$ не больше $log n$
]
#proof[#todo()]

Сжатие путей: переподвешиваем детей сразу к корню
```cpp
int get(int v) {
  return v == p[v] ? v : (p[v] = get(p[v]));
}

void join(int a, int b) {
  p[get(a)] = b;
}
```

#remark[#todo()]
