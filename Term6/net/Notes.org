#+PUBNOTE:html
#+SETUPFILE: ../../level-subj.org
#+title: Заметки к экзамену
#+OPTIONS: num:nil

* Историческая справка
Если узел A хочет поговорить с узлом B, в промежуточных узлах
буквально соединялся физически провод (линк), это называется *канальной
коммутацией*.

Будем разбивать данные на кусочки, предавать следующему узлу вместе с
информацией куда надо доставить --- *пакетная коммутация*. Есть
некоторые проблемы:
- У узла может забится буфер
- Пакеты могу призордит в другом порядке
- Пакет может заблудиться

* База
Интернет --- мнго независимых сетей, которые общаются друг с другом.

Виды линков:
1. Витая пара
2. Коаксиальные провода (как кабельное тв)
3. Оптический кабель (пластик/стекло)
4. Радио (WiFi, 4g, спутники)

Две задачи:
- Форвардинг (пересылка) \\
  Кому дальше пересылать
- Маршрутизация \\
  Строить таблицы для форвардинга

/Аналогия/: Маршрутищация --- построить путь из одного города в другой,
форвардинга --- для каждого промежуточного города, по какой дороге из
него выехать

*Congestion controls* --- решение проблемы забития очереди, когда
 входной канал шире чем выходной. Когда очередь заканчивается, пакеты
 теряются. Хочется знать с какой скороситью отправлять, чтобы очередей
 не возникало

Протоколы:
- RFC: Request for Comments
  Сначала появляется драфт, на него не стоит опираться
- IETF: Internet Engineering Task Force
- ISO: International Organization for Standartiozation
  Стандарты, Например ISO 8601 (формат даты)

Типичные слои:
- Applicaiton: HTTP, IMAP, DNS
- Transport: TCP, UDP
- Network: IP, кастомные внутри железок \\
  Марщрутиация пакетов от отправителя к получателю
- Link: Ethernet, WiFi, PPP (DSL, Dial-Up) \\
  Передача данных между соседними узлами
- Physical

*OSI* model:
# - L7 :: Application
# - L6 :: Presentation
# - L5 :: Session
# - L4 :: Transport
# - L3 :: Network
# - L2 :: Link
# - L1 :: Physical

* L3 IP
- IPv4
  32 bits \\
  /Пример/: =87.250.250.242=
- IPv6
  128 bits \\
  /Примеры/:
  - =2a02:06b8:0000:0000:0000:0000:0002:0242=
  - =2a02:6b8::2:242=
  - =::ffff:87.250.250.242=

IP Network:
Зафиксируем префикс сети. /Пример/:

| Address   | =87.250.250.0=    |
| Netmask   | =255.255.254.0=   |
| Wildcard  | =0.0.1.255=       |
| Network   | =87.250.250.0/23= |
| Hostmin   | =87.250.250.1=    |
| Hostman   | =87.250.251.254=  |
| Broadcast | =87.250.251.255=  |

Для сети =/31= можно использовать оба адреса, не смотря на то что они
broadcast и нулевой.

*Маршрутизация*. /Пример/:
#+begin_src 
192.168.99.0/24 dev wlan0
0.0.0.0/0 via 192.168.99.1  
#+end_src
=192.168.99.17= в первое правило

Если нужно отправит по адресу, отправляем по наиболее совпадающему правилу. /Пример/:
#+begin_src 
10.0.0.0/8 via 192.168.1.1
10.0.0.0/9 via 192.168.1.4
10.1.0.0/16 via 192.168.1.2
10.1.2.0/24 via 192.169.1.3  
#+end_src

- 10.1.3.0 во второе правило
- 10.10.10.10 во второе
- 10.200.1.1 в первое

*Как получить IP*: IANA выдает IP адреса.

** Специальные IP адреса
- Loopback
  - =127.0.0.0/8=
  - =::1/128=
- =0.0.0.0/8= (=::/128=)
Приватные адресы для локальной сети
- =192.168.0.0/16=
- =172.16.0.0/12=
- =10.0.0.0/8=
- =100.64.0.0/10=
- =fd00::/8= \\
  Должны быть вида =fd:<56 случайных бит>::/64=

Link local (Значат что не настроено): 
- =169.254.0.0/16=
- =fe80::/10=


Broadcast:
- =87.250.250.0/23=
  - =82.250.251.255= --- Directed broadcast (работает только в локальной сети)
- =255.255.255.255/32= --- Local network broadcast (работает только в локальной сети)

Multicast:
- =224.0.0.0/4=
  - =224.0.0.1= --- подписка на адрес в этой сети
- =ff00::/8=

[[file:1.png]]

| Version              | 4 либо 6                             |
| IHL                  | длина заголовка                      |
| Next Header          | Что дальше: TCP, UDP, расширение, .. |
| Total/Payload length | Размер после/вместе с заголовком     |

Минимальный размер
- IPv4 =768= байт
- IPv6 =1506= байт

Flags (More Fragments), Fragment offset --- фрагментация пакета. Если
получатель не поддреживает фрагменты, то это проблема клиента. Решение
--- уменьшить размер пакета. Можно поставить флаг, чтобы промежуточные
узлы не фрагментировали пакет

/NB/: Jumbograms --- переписать размер пакета, гораздо большим числом
** Nat
Как ходить в интернет с локальным адресом.
[[file:2.svg]]

** ICMP
Поверх протокола IP.
- Echo request
- Echo reply
- Destination unreachable
  - Destination host unreachable - не дошел
  - Destionation port unreachable - дошел до конечной точки, но не смог отдать на уровень выше
  - Destination network unreachable - не дошел
  - Fragmentation required - пакет слишком большой
- Time Exceeded
- +Traceroute+ --- Все промежуточные узлы должны отправить обратно пакет

* L2
Ethernet, WiFi.

[[file:3.svg]]

Broadcast MAC Address: =ff:ff:ff:ff:ff:ff=

Как передаются эти сообщения. Компьютеры подключены к коробочке. Коробочки бывают разные:
- Хаб (L1)
- Коммутатор (свитч) L2 \\
  Запоминает MAC адрес для каждого порта, то есть получатель должен
  отправить что-то, чтобы его запомнили. Есть некоторые проблемы с циклами
- Маршрутизатор L3

Хотим узнавать по IP адресу MAC адрес. Отправляем ARP запрос на MAC
broadcast: Who has =1.2.3.4=? Если такое устройство есть, оно отправляет
нам свой MAC.

/NB/: =arp -n= --- получить локальную таблицу MAC адресов

Для IPv6 NDP (Neighbor Discrovery Protocol). Работает поверх IP.
- Address resolution
- Router discovery
- Redirection

** DHCP
Спросить у сети, какой адрес можно взять, кто роутер, какие
DNS. Работает поверх UDP. Отправляем с адреса =0.0.0.0= на
=255.255.255.255=. /Роутер/ выдает адрес и сразу шлет на него пакет.

[[file:4.svg]]

* L4 TCP, UDP
** UDP
#+begin_src
s = socket()
bind(s, 53)
sockaddr{IP, port}
send_to(s, data, dst)
recvfrom(s, *data, *src)
#+end_src

[[file:5.jpeg]]

Порты 1-1024 обычный пользователь занять не может

Хотим отправить много данных, которые не влезают в один UPD пакет \\
*TFTP*. Работает поверх UDP:
[[file:6.png]]

Если клиент примет два одинаковых пакетах, получится так, что все
следующие части будут удвоены. Эта проблема была решена.
** TCP
Server:
#+begin_src 
s = socket()
bind(s, 80)
s2 = accept(s)
read(s2)
write(s2)
#+end_src

Client:
#+begin_src 
s = socket()
connect(s, addr)
write(s)
read(s)
#+end_src

[[file:7.png]]

Если отправим больщой файл, не дожидаясь подтверждения, будет
плохо. Поэтому есть Congestion Window --- сколько байт, которые были
отправлены, еще не были подтверждены получателем. Как выбирать окно:
экспоненциально увеличивая размер, выясняем максимальный без потерь.

Не хотим слать ACK на каждый пакет. Будем ACK'ать сразу кусок данных,
дожидаясь еще по таймауту.

Как клинту сообщить серверу, что пакет потерялся:
- Fast Retransmit \\
  Если какой-то пакет посередине потерялся, то отправялем ACK \(x\),
  где \(x\) --- последний пакет, до которого получено все по порядку.
- Selective Acknowledgments

Как увеличивать окно:
- AIMD (исторический алгоритм):
  #+begin_src 
  ok: cwnd += 1
  not ok: cwnd /= 2  
  #+end_src
- BIC \\
  Увеличиваем по параболе
- CUBIC \\
  Увеличиваем по кубической параболе
- BBR \\
  Отступить не когда уже потеряли пакет, а когда подходим к этому
  моменту. BBR 1 забивал CUBIC, BBR 2 решил эту проблему, но в сети
  остаются старые протоколы.

Флаг ECE (congestion echo) в TCP от клиента означает, что произошел затык на пути к
клиенту. Клиент узнает по флагу ECN (congestion notice) в IP пакете.

Затые может произойти у клиента в железе. В ответе серверу можем
попросить его ограничить его окно, в том числе поставить 0.

[[file:8.jpeg]]

Проверяем что клиент не спуфит адреса. Все ок, если сервер выполняет
меньше работы чем клиент. Можем выдавать SYN Cookie, чтобы следующее
подключение происходило сразу.

Когда соединение закрывается, обе стороны, грубо говоря, должны
послать FIN.

[[file:9.svg]]

Фаг PUSH, говорит сразу отдать пакеты из буфера приложению.
* Routing
- Static routing
- Link state \\
  Строим карту сети, владея информацией о всей сети, строим маршруты
- Distance vector \\
  Принимаем информацию от соседей, принимают решения локально
- Software-defined network

** *RIP* (Routing Information Protocol)
[[file:10.jpeg]]

Получаем информацию от соседей, выбираем наиболее короткий путь. Когда шлем сообщения:
- Когда подключился новый провод
- Когда попросили
- По таймеру
В чем проблема: Циклы после исчезновения конечного узла: Если получили
информацию об узле, не сообщаем обратно эту информацию. Так же, при
исчезновении узла, можем сообщить, что расстояние до него 16
(максимально возможное)

** OSPF (Open Shortest Path First)
Каждый узел по таймеру шлет информацию соседям, так, что у каждого
узла есть полная карта сети. Каждый узел строит кратчайший путь.

Проблема: Если появляется/рвется линк, у разных узлов получаются разные карты сети.

** IS-IS (Intermediate System to Intermediate System)
В отличие от OSPF, который работает над UDP, IS-IS работает по чему-то типа IP.

** BGP (Border Gateway Protocol)
- eBGP, Autonomous System (AS)
- iBGP
- TCP port =179=

Номера AS берем у IANA, AS обычно принадлежат крупным организациям. У
каждой AS есть список префиксов, которые доступны в этой
AS. Автономные системы связаны. Спрашиваем у соседей путь к префиксу,
запоминаем пути. Грубо говоря, выбираем самый короткий маршрут.
- Не принимаем пути, которые содержат нашу AS
- У AS есть доп информация (16 битная чиселка). Соседи сами
  договариваются что оно значит.
** Internet
Маленький провайдер идет к большому. Платит деньги за то, чтобы
большой провайдер доставлял пакеты в интернет и возвращал
ответы. Большой провайдер знает про много префиксов, рассказывает о
путях до этих префиксов. Платим много денег за то, чтобы большой
провайдер доставлял трафик до, например, гугла. Поэтому ниш провайдер
может установить соединение с гуглом напрямую.

Есть другой вариант. Существуют организации IX (Internet Exchange). У
нее есть сови AS. И мы и гугл расскажут ей свои префиксы. Здесь платим
только за порт, а не за трафик. IE может доставить трафик только до
тех, кто к ней подключен, в отлии от большого провайдера, который
может доставить трафик куда угодно.

Как большие провайдеры жто делают: Сушествует немного Tier 1
провайдеров, к которым подключены все. Большие провайдеры платят
им. Tier 1 провайдеры тоже соединены между собой. Они никому не платят
за трафик.

* DNS
#+begin_src 
label \(\le\) 63 (между точками)
name \(\le\) 254
[a-zA-Z0-9-]
#+end_src

Что позволяет зранить DNS:
- =A= --- IPv4 адрес
- =AAAA= --- IPv6 адрес
- =CNAME= --- алиас для другого имени
- =TXT= --- произвольный текст
- =MX= --- почтовый сервер

[[file:11.gif]]


=NS= --- за эту хону отвечает другой сервер

*Reverse DNS* --- узнать по IP домен. Для таких доменов есть зона =.arpa=.

DNS работает по:
- =UDP= на порту =53= (ограничено 512 байт)
- =TCP= на порту =53=
- DNS over TLS
- DNS over HTTPS

*EDNS(0)* (OPT флаг):
- Можно больше 512 байт по UDP
- EDNS --- если спрашиваем через рекурсивные DNS, то они прокидывают IP того кто спрашивает

*DNSSEC*:
- RRSIG -- подпись
- DNSSEC --- публичный ключ
- DS --- делигирование DNSSEC другой зоне
- NSEC/NSEC3 --- Домен не существует
* L7 HTTP
#+begin_src 
GET /hello.txt HTTP/1.1
Host: example.com


#+end_src


URI: =scheme:[//[user[:password]@]host[:port]]path[?query][#fragment]=


** Методы
- =GET= (идемпотентный)
- =HEAD= --- только загловки (идемпотентный)
- =POST=
- =PUT=
- =DELETE=
- =TRACE=
- =OPTIONS=
- =CONNECT=
- =PATCH=

** Коды ответов
| 200 | OK                    |                                                           |
| 204 | No Content            |                                                           |
|-----+-----------------------+-----------------------------------------------------------|
| 301 | Moved Permanently     | Навсего переместился, можно закэшировать                  |
| 302 | Found                 | Временно перемещен                                        |
| 304 | Not Modified          | Уже есть в кэше                                           |
| 307 | Temporary Redirect    |                                                           |
|-----+-----------------------+-----------------------------------------------------------|
| 400 | Bad Request           |                                                           |
| 401 | Unathorized           |                                                           |
| 403 | Forbidden             |                                                           |
| 404 | Not Found             |                                                           |
| 413 | Payload Too large     |                                                           |
| 414 | URI Too Long          |                                                           |
|-----+-----------------------+-----------------------------------------------------------|
| 500 | Internal Server Error |                                                           |
| 502 | Bad gateway           | Сервисы от которых сервер хочет получить ответ недоступны |

** Заголовки
- =Connection: Keep-Alive= --- не закрывать TCP соединение
- =Accept-Encoding: gzip, deflated= --- как можно сжать данные
- =Refresh: 5; url=https://example.com= --- через время отправит на другую страницу
- =If-Modified-Since: <date>= --- отдать, если файл менялся с этого времени
- =Last-Modified: <date>= --- когда последний аз менялся
- =Range: bytes 1234-1345= --- попросить файл не целиком, а определенный фрагмент

** HTTP/2
- SPDY \\
  Google внедрил в свои продукты
- Multiplexing \\
  Позволяет получать несколько файлов в одном соединении
- Server push \\
  Когда клиент просит страничку, сервер отдает еще и нужные файлы
- Only encrypted transport

*HTTP/3*: QUIC вместо TCP

** TLS
Сначала проверяет что оба клиента на самом деле те, кто они есть.
- 1.2 \\
  RSA или Диффи-Хелман
- 1.3 \\
  Диффи-Хэлман

*Perfect Forward Secrecy*: Если сервер взломают и получат прошлые
 сессии, то нельзя будет их расшифровать. Используется что-то вроде
 одноразовых ключей.

** CA
Certificate Authority. Просим CA подписать пару: наш публичный ключ и
домен. У клиента есть список ключей всех CA, он может убедится в
подлиннсти публичного ключа сервиса.

CA может подписывать ключи для промежуточных CA.

Протокол:
Клиент передает:
- Список поддерживаемых шифров
- рандом
- Расширения
Сервер передает:
- Выбранный шифр
- рандом
- Расширения

*(E)SNI*

** HTTPS
*HSTS*: Можно сказать, что к нашему серверу нельзя подключаться не по HTTPS. \\
*HKPK*: Говорим клиентам, какие сертификаты могут испольщоваться
