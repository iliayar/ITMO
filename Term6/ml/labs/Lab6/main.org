#+TITLE: Lab 6

#+begin_src jupyter-python
import sys
sys.executable 
#+end_src

#+RESULTS:
: # Out[236]:
: : '/nix/store/pkld6nc54inn5dsfvzddr813p1g7ffmc-python3-3.9.6-env/bin/python3.9'


* Load datasets

#+begin_src jupyter-python
import torch
import torchvision
import torchvision.transforms as transforms

batch_size = 10

transform = transforms.Compose([
    transforms.ToTensor(),
    # transforms.Normalize((0.5, 0.5, ))
])

mnist_train = torchvision.datasets.MNIST('data/mnist', download=True, transform=transform, train=True)
mnist_test = torchvision.datasets.MNIST('data/mnist', download=True, transform=transform, train=False)
fashion_mnist_train = torchvision.datasets.FashionMNIST('data/mnist', download=True, transform=transform, train=True)
fashion_mnist_test = torchvision.datasets.FashionMNIST('data/mnist', download=True, transform=transform, train=False)

mnist_train_loader = torch.utils.data.DataLoader(mnist_train,
                                                batch_size=batch_size,
                                                shuffle=True)
#+end_src

#+RESULTS:
: # Out[1]:

#+begin_src jupyter-python
mnist_train
#+end_src

#+RESULTS:
#+begin_example
# Out[2]:
,#+BEGIN_EXAMPLE
  Dataset MNIST
  Number of datapoints: 60000
  Root location: data/mnist
  Split: Train
  StandardTransform
  Transform: Compose(
  ToTensor()
  )
,#+END_EXAMPLE
#+end_example


#+begin_src jupyter-python :results raw drawer
import numpy as np
import matplotlib.pyplot as plt

dataiter = iter(mnist_train_loader)
images, labels = next(dataiter)

print(np.shape(images))


plt.imshow(np.transpose(images[1], (1, 2, 0)))
#+end_src

#+RESULTS:
:results:
# Out[3]:
: <matplotlib.image.AxesImage at 0x7faf257c4ac0>
[[file:./obipy-resources/UUfnOj.png]]
:end:

* COMMENT Train

#+begin_src jupyter-python
import torch.nn as nn
import torch.nn.functional as F


# 0.9256
net = nn.Sequential(
    nn.Conv2d(1, 8, 5), # 24
    nn.MaxPool2d(2, 2), # 12
    nn.Conv2d(8, 1, 3), # 10
    nn.MaxPool2d(2, 2), # 5
    nn.Conv2d(1, 100, 5), # 1
    nn.Flatten(),
    nn.Linear(100, 10),
    nn.Softmax(1),
).to('cuda')
#+end_src

#+RESULTS:
: # Out[4]:

#+begin_src jupyter-python
import torch.optim as optim

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(net.parameters())
#+end_src

#+RESULTS:
: # Out[5]:

#+begin_src jupyter-python :async yes
from tqdm import tqdm
loss_log = []
for epoch in range(5):

    running_loss = 0.0
    for i, data in enumerate(tqdm(mnist_train_loader), 0):

        inputs, labels = data
        inputs = inputs.to('cuda')
        labels = labels.to('cuda')

        optimizer.zero_grad()

        outputs = net(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()

        if i % 100 == 99:
            # print(f'[{epoch + 1}, {i + 1:5d}] loss: {running_loss / 100:.3f}')
            loss_log.append(running_loss / 100)
            running_loss = 0.0
#+end_src

#+RESULTS:
: # Out[6]:

#+begin_src jupyter-python :results raw drawer
plt.figure(figsize=(8, 6))
plt.plot(loss_log)
plt.show()
#+end_src

#+RESULTS:
:results:
# Out[7]:
[[file:./obipy-resources/1CEo25.png]]
:end:



#+begin_src jupyter-python :results raw drawer :async yes
test_loader = torch.utils.data.DataLoader(mnist_test, batch_size=len(mnist_test))
data, labels = next(iter(test_loader))
preds = net(data.to('cuda')).to('cpu')
print(preds.argmax(dim=1))
labels_pred = preds.argmax(dim=1).detach().numpy()
T = 0
for label_true, label_pred in zip(labels, labels_pred):
    T += label_pred == label_true
T / len(mnist_test)
#+end_src

#+RESULTS:
:results:
# Out[8]:
: tensor(0.9030)
:end:

#+begin_src jupyter-python :results raw drawer
import seaborn as sns
stacked = torch.stack((labels, preds.argmax(dim=1)), dim=1)
cmt = torch.zeros(10, 10, dtype=torch.int64)
for p in stacked:
    tl, pl = p.tolist()
    cmt[tl, pl] += 1
plt.figure(figsize=(16, 9))
sns.heatmap(cmt, annot=True, cmap='Blues', fmt='d')
plt.show()
#+end_src

#+RESULTS:
:results:
# Out[20]:
[[file:./obipy-resources/9SXb4X.png]]
:end:

#+begin_src jupyter-python
cmt[9][0] 
#+end_src

#+RESULTS:
: # Out[25]:
: : tensor(10)

#+begin_src jupyter-python
msi = [[None for i in range(10)] for i in range(10)]
for d, p, l in zip(data.to('cpu'), preds, labels):
    for i in range(10):
        if msi[l][i] == None or msi[l][i][0] < p[i]:
            msi[l][i] = (p[i], d)
#+end_src

#+begin_src  jupyter-python :results raw drawer
from mpl_toolkits.axes_grid1 import ImageGrid

fig = plt.figure(figsize=(10, 10))
grid = ImageGrid(fig, 111, nrows_ncols=(10, 10), labels=['1', '2', '3', '4', '5', '6'])

for i, ax in enumerate(grid):
    ax.imshow(np.transpose(msi[i // 10][i % 10][1], (1, 2, 0)))

plt.show()
#+end_src

#+RESULTS:
:results:
# Out[36]:
[[file:./obipy-resources/JijN6t.png]]
:end:


