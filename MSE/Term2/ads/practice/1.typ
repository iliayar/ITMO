#import "common.typ": *

#show: doc => practice(
  subj: [Алгоритмы и структуры данных. Часть 2],
  title: [Практика 1],
  date: [10 февраля],
  number: 1,
  doc
)

#task(numbering: (..) => numbering("1", 1))[]
#solution()[
  Пусть $alpha_i = d_i / c_i$. Ребра --- обменники, вершины --- валюты. Найдем цикл отрицательного веса с весами $- log alpha_i$: $sum - log alpha_i < 0$. Потому что $product alpha_i > 0$ значит что можем бесконечно обогащаться.
]

#task(numbering: (..) => numbering("1.a", 4, 1))[]
#solution()[
  Заметим знакомую форму $0 <= delta_(i j) + x_i - x_j$. Получается если найдем Ф.Б решение то это будет решение системы. И если есть отрицательный цикл, то решения системы не будет, т.к. если сложим неравенства по отрицательному циклу получим $0 <= sum delta < 0$.
]

#task(numbering: (..) => numbering("1", 5))[]
#solution()[
  Как понять что нет цикла отрицательного веса на пути от $a$ до $b$. Сделаем под итерацию Ф.Б, запомнить какие вершины прорелаксировались. Запустить дфс из $a$ и обратный дфс из $b$. Если нашли вершины, прорелаксированную на последней итерации, которая достпна из $a$ и из нее доступно $b$, то нашли такой путь с циклом посередине.
]

#task(numbering: (..) => numbering("1", 6))[]
#solution()[
  Если $d[a, b] = d[a, u] + w(e) + d[v, b]$
]

#task(numbering: (..) => numbering("1", 8))[]
#solution()[
  Заменить релаксацию во Флойде $d[i, j] = min(d[i, j], max(d[i, k], d[k, j]))$
]

#remark()[
  Алгебраический объект с операциями $a + b$, $a compose b$, $a^*$. Пусть $d[k, i, j]$ --- путь из $i$ в $j$ который проходит по вершинам с номерами не больше $k$. Тогда обновление во Флойде
  $ d[k, i, j] = d[k - 1, i, j] + d[k - 1, i, k] compose (d[k - 1, k, k])^* compose d[k - 1, k, j] $

  Решение 5: $x compose y := x + y$, $x + y := min(x, y)$, $x^* = min(0, x, 2x, dots) = cases(0 quad x >= 0, -infinity quad x < 0)$

  Решение 8: $x compose y := max(x, y)$, $x + y := min(x, y)$, $x^* = min(-infinity, x, max(x, x), max(x, x, x), dots) = -infinity$
]
