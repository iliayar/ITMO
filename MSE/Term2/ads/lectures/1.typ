#import "../../../../other/typst/lecture_mse.typ": *

#show: doc => lecture(
  subj: [Алгоритмы и структуры данных. Часть 2],
  title: [Лекция 1],
  date: [10 февраля],
  number: 1,
  program: "ITMO MSE y2025",
  doc
)

= Графы с отрицательными ребрами

== Форд-Белман с очередью

Пока можем улучшать ребро, улучшаем

#pseudocode-list()[
  - *while* $"Run"$
    - $"Run" <- 0$
    - *for* $e : a -> b$
      - *if* $d_a + w_(a b) < d_b$
        - $d_b <- a_a + w_(a b)$
        - $"Run" <- 1$
]
+ очередь с верщиными для которых поменялось расстояние

#remark[
  Если внешний цекл сделал $> n - 1$ итераций, то есть цикл отрацательного веса.
]

#theorem[
  Эта штука работате за $O(n dot m)$.
]
#proof[
  Пусть $"depth"$ --- глубина дерева минимальных путей. Тогда время работы $"Time" = E dot "depth"$. Где $"depth"$ рандомный в среднем $log n$.
]

== Через динамику
$"dp[k, v]"$ --- минимальный вес пути. Пересчитывем переход $k |-> k+1$ за $cal(O)(E)$.
#remark[
  $ forall e: v -> u quad "dp"[k + 1, v] = min("dp"[k + 1, v], "dp"[k, v] + w_(v u)) $
]

== Отрицательные циклы

#remark[
  Если делаем Форда-Белмана на очереди, то если сделали $n$ итераций то существует отрицательный цикл. Однако нельзя сказать что если улучшили на последней итерации расстояние до $v$, то не значит что она в цикле, она достижима из него. Поэтому чтобы найти сам цикл надо пройти по дереву обхода обратно. Если найдем какой-то цикл то это и есть он.
]
#proof[
  Предположим что не закциклились. Тогда есть путь от $s$ до $v$. Рассмторим какое-то $p[a]$ где $e : a -> dot$. 
  $ d[p[a]] + w_e <= d[a] ==> undershell(d[s], 0) + undershell(omega("path"), <= n - 1) <= undershell(d[v], #text[$n$-тая фаяа]) $

  Покажем что этот цикл отрицательный. #todo()
  $ sum d + omega("cycle") <= sum d $

]

== Флойд

#pseudocode-list[
  - $d[i, j] = cases(w_(i j), +infinity)$
  - *for* $k$
    - *for* $i$
      - *for* $j$
        - $d[i, j] <-^"Relax" d[i, k] + d[k, j]$
]

#proof[
  - $k = 0$. Очев
  - $k |-> k + 1$. Уже знаем минимум для всех $k$. Очев? #fixme()
]

#remark[
  - Отрицательные циклы если есть $d[u, v] < 0$
  - Восстановление пути. Храним следующую вершину в пути $p[i, j]$. Изначально $p[i, j] = j$. Если обновляем через $k$, то $p[i, j] = p[i, k]$. Потом идем по $i = p[i, j]$.
]

== Потенциалы

Можем поменять веса ребер так для какого-то $e : a -> b$. $w_e |-> w_e + p[a] - p[b]$. Посмотрим как изменятся веса путей $w("path") |-> w("path") + p[s] - p[t]$. Где $p$ --- *потенциалы* --- любые вещественные числа. Можно заметить что минимальный путь останется минимальным.

Как подобрать $p$ так чтобы веса стали неотрицательными. Найдем расстояние из фиктивной вершины до всех остальных вершин Форд-Белманом. Возьмем расстояния $d$ как потенциалы.
#proof[
  Покажем что $w_e + d[a] + d[b] >= 0$. Если оказалось что $w_e + d[a] < d[b]$ то это значит что $d[b]$ посчитано неверно. Противоречие.
]

=== Джонсон
Чтобы найти расстояния от каждой вершины до каждой то Флойдом $V^3$. Но можем Ф.Б найти потенциалы, избавиться от отрицательных ребер и запустить Дейкстру $n$ раз:
$ #[F.B.] + V dot #[Dijkstra]$ --- $V E + V^2 log V <= V^3 $

== Транизитивное замыкание
Можно решать Флойдом:
#pseudocode-list[
  - *for* $k$
    - *for* $i$
      - *for* $j$
        - *if* $c_(i k) and c_(k j)$
          - $c_(i j) <- T$
]
Пооптимизируем. Заметим что делаем `c[j] |= c[k]`. Можно сделать на битсетах.

