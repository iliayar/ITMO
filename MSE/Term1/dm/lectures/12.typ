#import "/other/typst/lecture_mse.typ": *
#import "/MSE/Term1/dm/common.typ": *

// TODO: Move to common
#import "@preview/h-graph:0.1.0": enable-graph-in-raw, polar-render
#show raw.where(lang: "graph"): enable-graph-in-raw(polar-render)

#show: doc => lecture(
  subj: [Дискретная математика],
  title: [Лекция 12],
  date: [3 декабря],
  number: 12,
  doc
)

= Продолжение

#definition()[
  Если между любыми двумя вершинами графа есть путь, то граф *связный*.
]

#remark()[
  Т.к. отношение связности это отношение эквивалентности, то любой граф можно разбить на связные подграфы --- факторизовать.
]

#definition()[
  Такие подграфы называются *компонентами связности*.
]

#symb()[$c(G)$ --- количество компонент связности графа $G$]

#definition()[
  Граф называется *регулярным*, если все степени вершин равны. Если они равны $k$, то говорим что граф $k$-регулярный.
]
#remark()[
  Кубический граф --- $3$-регулярный
]
#remark()[
  Для $k$-регулярного графа
  $ |E(G)| = (|V(G)| dot k) / 2 $
]

#definition()[
  Граф без кратных ребер и петель называется *простым*.
]

#remark()[
  С этого момента считаем все графы простыми
]

#definition()[
  Граф называется *полным* если две любые его вершины смежны
]
#symb()[$K_n$]
#remark()[$|E(G)| = (n (n - 1)) / 2$, где $n = |V(G)|$]

#definition()[
  $overline(G)$ --- называется дополнением графа $G = angle.l V(G), E(G) angle.r$, если $V(overline(G)) = V(G)$ и $E(overline(G))$ такое что:
  - $E(overline(G)) inter E(G) = emptyset$
  - $E(overline(G)) union E(G) = E(K_n)$, где $n = |V(G)|$
]

== Деревья

#definition()[
  *Дерево* --- связный граф без циклов
]

#definition()[
  *Лес* --- граф без циклов
]

#definition()[
  *Мост* --- ребро при удалении которого увеличивается количество компонент связности
]

#statement()[
  $e$ --- мост $<==>$ не существует цикла содержащего $e$.
] <stmt-bridge-no-cycle>
#proof()[
  - $(==>)$ Пусть существует цикл содержащий $e$. Удалим $e$, количество компонент связности не увеличится, хотя $e$ --- мост. Противоречие
  - $(<==)$ Допустим что $e$ --- не мост. Удалим $e$. Пусть $e$ соединяло вершины $u$ и $v$. Т.к. $e$ не мост то в $G - {e}$ между $u$ и $v$ есть путь $u e_1 v_1 e_2 dots e_k v$. Вернем $e$, получим цикл с $e$. Противоречие.
]

#definition()[
  $T$ --- дерево. Если $"deg"(v) = 1$, то $v$ называется *листом*.
]

#statement()[
  В любом дереве ($|V(G)| >= 2$) есть хотя бы $2$ листа.
] <stmt-leaf>
#proof()[
  Рассмотрим путь наибольшей длины $v_1 e_1 v_2 e_2 dots v_(k - 1) e_(k - 1) v_k$. Докажем что $v_1$, $v_k$ --- листья. Пусть $v_k$ не лист, тогда существует $e_k$ инцидентное $v_k != e_k$.
  1. $e_k$ не может быть инцидентным $v_i$, $i in [1; k - 1]$ иначе будет цикл
  2. $e_k$ не может быть инцидентным вершинам не из пути, т.к. нашелся бы путь лучше
]

#statement()[
  $T$ --- дерево. $|E(T) = |V(T)| - 1$.
] <stmt-tree-edges-vertices-number>
#proof()[
  Индукция по $n = |V(T)|$. \
  База: $n = 1$ --- очевидно \
  ИП: $k |-> k + 1$. Рассмотрим $T$ на $k + 1$ вершинах. У $T$ есть лист (по #ref(<stmt-leaf>, supplement: [утверждению])). Назовем его $v$. Рассмотрим $T - {v}$ --- это дерево на $k$ вершинах. По ИП 
  $ |E(T)| - 1 = |E(T - {v})| = |V(T - {v}| - 1 = |V(T)| - 2 ==> |E(T)| = |V(T)| - 1 $
]

#corollary_statement()[
  $G$ --- лес. $|E(G)| = |V(G)| - c(G)$
]

#theorem()[
  $T$ --- дерево $<==>$ $T$ --- связный и $|E(T)| = |V(T)| - 1$.
]
#proof()[
  - $(==>)$ уже доказано
  - $(<==)$ Если в $T$ есть цикл, то удалим любое ребро этого цикла. Повторим пока не получим ацикличный граф. Этот граф $T'$ --- дерево. Значит $|E(T')| = |V(T')| - 1$.
  $ |E(T')| = |V(T')| - 1 = |V(T)| - 1 = |E(T)| $
  Значит не удалили никакие ребра, т.е. применили алогримт удаление ровно 0 раз. Значит изначально было дерево
]

#corollary()[
  $G$ --- связный, то $|E(G)| >= |V(G)| - 1$
]
#corollary()[
  В доказательстве представлен алгоритм получения остовного дерева
]

#theorem()[
  $T$ --- дерево $<==>$ $T$ --- ацикличен и $|E(T)| = |V(T)| - 1$
]
#proof()[
  - $(==>)$ уже знаем
  - $(<==)$ Если $T$ не связен, то добавим ребро между компонентами связности (циклы не появятся по #ref(<stmt-bridge-no-cycle>, supplement: [утверждению]))
    Повторяем пока получим связный граф. Тогда он будет деревом $T'$.
    $ |E(T')| = |V(T'| - 1 = |V(T)| - 1 = |E(T)| $
    Значит проделали добавление ребер ровно $0$ раз, значит $T'$ и есть $T$.
]

#theorem()[
  $T$ --- дерево $<==>$ $T$ --- связный и любое ребро $T$ --- лист.
]
#proof()[
  - $(==>)$  Связность есть. Пусть найдется ребро $e = u v$, не являющееся мостом. Значит в $T - {e}$ между $u$ и $v$ есть путь $u e_1 dots e_k v$. Тогда в $T$ есть цикл $u e_1 dots e_k v e u$. Значит $T$ --- не дерево. Противоречие.
  - $(<==)$ Связность есть. Ацикличность следует из #ref(<stmt-bridge-no-cycle>, supplement: [утверждения])
]

#theorem()[
  $T$ --- дерево $<==>$ между любыми двумя вершинами существует единственный путь
]
#proof()[
  - $(==>)$ существование следует из связности. Единственность из ацикличности
  - $(<==)$ из существования следует связности. Из единственности ацикличность
]
