#import "common.typ": *


#show: doc => practice(
  subj: [Алгоритмы и структуры данных],
  title: [Практика 4],
  date: [2 октября],
  number: 4,
  doc
)

#task()[]
#solution()[
  Аналогично доказательству нижней границы сравнений любой сортировки
  $ 
    2^k >= frac(n!, 100^n) \
    k >= log frac(n!, 100^n) \
    k >= log n! - n dot underbrace(log 100, ~6.6) \
    k = Theta(n log n) - n dot log 100
  $
]

#task()[]
#solution()[
  Бин-поиском ищем куда поставить $x$
]
#remark()[Битовые приколы]

#task()[]
#solution()[
  Строим путь по минимумам вниз, по этому пути бин-поиск
]

#task()[]
#solution()[
  Заводим две кучи по минимуму $U$ и по максимуму $D$. Поддерживаем равные размеры.
  - $||U| - |D|| <= 1$
  - $forall u in U, d in D: d <= u$
]  

#task()[]
#solution()[
  1. Просто убираем $k$ потом кладем обратно
  2. Для $k$-того минимум имеем $k$ кандидатов, спускаемся по дереву, собираем кандидатов. На массиве поиск минимума за $k$.
  3. То-же самое но вместо массива куча
]

#task()[]
#solution()[
  - $a_i in K, |K| = m$, $p_i$ --- частота элементов? (вероятность встретить элемент?), $sum_i p_i = 1$
  Сколько различных выходов алгоритма: $frac(n!, product_i (n p_i)! )$
    $ 
      ln frac(n!, product_i (n p_i)!) = ln n! - sum_i ln (n p_i)! >= n ln n - sum_i (n p_i) ln (n p_i) =  \
      = n ln n - n sum_i p_i ln n + n sum_i ln 1 / p_i = n dot (sum p_i log 1 / p_i - 1)
    $
  - Энтропия максимальна когда $p_i = 1 / m$
]

#remark()[
 $sum p_i log 1 / p_i$ --- энтропия
]

#task()[]
#solution()[
  1. #todo()
  2. #todo()
  3. #todo()
  4. Линейный поиск по головам куч, их $O(log n)$
  5. Сложение двух чисел в двоичной системе счисления (мержим деревья одного порядка, получаем дерево на порядок больше). $O(log n)$
  6. Сложение с 1
  7. Удаляем минимум из дерева с минимумом, получаем кучу из его детей, складываем
  8. Надо хранить ссылку на предка
  9. `DecreaseKey` + `ExtractMin`
]
