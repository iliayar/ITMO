#import "common.typ": *

// touch: 1

#show: doc => practice(
  subj: [Алгоритмы и структуры данных],
  title: [Практика 7],
  date: [24 октября],
  number: 7,
  doc
)

= ДЗ

#task(numbering: (..) => numbering("1", 5))[]
#solution()[
  Бор с отсортированными ребрами. Как отсортировать ребра: скинем все символы в один массив, отсортируем.
]

= Практика

#task(numbering: (..) => numbering("1.a", 1, 2))[]
#solution()[
  В массиве где не уникальные элементы, удалим все символы которых нет во втором. Заменим символы в первом массиве на их индексы во втором. Достаточно найти максимальную возрастающую подпоследовательность

  Как найти ее за $cal(O)(n log n)$. $L_k$ --- минимальное значение элемента на который может заканчивается максимальная возрастающая подпоследовательность длины $k$. $L_(k + 1) > L_(k)$. Бин-поиск по $L$.
]

#task(numbering: (..) => numbering("1.a", 2, 2))[]
#solution()[
  $f(k, s)$ --- какую максимальную цену можно набрать из первых $k$, с максимальным весом $S$.
  $ f(k + 1, s) = max cases(
    f(k, s),
    v_k + f(k, s - w_k) quad "," s >= w_k
    )
  $

  Как использовать $cal(O)(S)$ памяти:
  1. Хранить только текущую и предыдущую строчку
  2. Можем использовать один массив и идти по нему слева направо по увеличению $s$.
]
#task(numbering: (..) => numbering("1.a", 2, 1))[]
#solution()[
  $ f(k + 1, s) = max cases(
    f(k, s),
    v_k + f(k + 1, s - w_k) quad "," s >= w_k
    )
  $
]
#task(numbering: (..) => numbering("1.a", 2, 3))[]
#solution()[
    $f_(s_0) -> max$. Будет верно что $exists k : f_(s_0) = v_k + f_(s_0 - w_k)$. Найдем эти $k$.
]

#task(numbering: (..) => numbering("1.a", 2, 4))[]
#solution()[
    $f_s = infinity$ --- если нельзя набрать $s$. $f_s = k$ --- если $s$ можно набрать и $k$ --- минимальная длина префикса с предметами которые входят в набор.
]

#task(numbering: (..) => numbering("1.a", 3, 1))[]
#solution()[
  $ vec(a_n , b_n) = mat(1, 2; -1, 10) vec(a_(n - 1), b_(n - 1)) =  mat(1, 2; -1, 10)^n vec(a_0, b_0) $
  Умеем возводить матрицы в степень $n$ за $cal(O)(log n)$.
]

#task(numbering: (..) => numbering("1.a", 3, 2))[]
#solution()[
  $ vec(a_n, b_n, c_n, c_(n - 1), 1) = mat(?, ?, ? ,?, 1; ?, ?, ? ,?, 5;?, ?, ? ,?, 0;0, 0, 1 ,0, 0;0, 0, 0 ,0, 1;) dot vec(a_(n - 1), b_(n - 1), c_(n - 1), c_(n - 2), 1) $
]

#task(numbering: (..) => numbering("1", 4))[]
#solution()[
  Разбиваем многоугольник один треугольником на две части, где всегда не больше одной стороны это диагональ.
  #pseudocode-list()[
    + $f_(i, j) <- infinity$
    + $f_(i, (i + 1) mod n) <- 0$
    + $f_(i, i) <- $
    + *for* $k = (i + 1) mod n$; $k != j$; $k = (k + 1) mod n$
      + $f_(i,j) <- min(f_(i, j), f_(i, k) + f_(k, j) + "cost"(i, j, k))$
  ]
]
