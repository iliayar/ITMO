#import "common.typ": *


#show: doc => practice(
  subj: [Алгоритмы и структуры данных],
  title: [Практика 5],
  date: [9 октября],
  number: 5,
  doc
)


#task(numbering: (..) => numbering("1.a", 1, 1))[]
#solution()[
  Отсортируем оба массива, почему это правильно. Допустим что нет, переставим два элемента в $a$ и посмотрим на разницу сумм:
  $ 
    S_1 - S_2 = a_i b_i + a_(i + 1) b_(i + 1) - a_(i + 1) b_i - a_i  b_(i + 1) = \
    = b_i (a_i - a_(i + 1)) + b_(i + 1) (a_(i + 1) - a_i) = (b_(i + 1) - b_i) dot (a_(i + 1) - a_i) > 0 \
    S_1 > S_2
  $
  Будем использовать пару $(S, I)$, где $I$ --- количество инверсий
]

#task(numbering: (..) => numbering("1.a", 1, 1))[]
#solution()[
  Домножим на $-1$ один из массивов, решим задачу с максимумом
]

#task(numbering: (..) => numbering("1", 2))[]
#solution()[
  Три указателя, поддерживаем в начале блок из $1$, в конце сначала блок из $2$, потом из $3$. Идем слева и свапаем элементы в нужный блок (если нужно).
]

#task(numbering: (..) => numbering("1", 3))[]
#solution()[
  Заводим массив на $2k$ элементов, пихаем во вторую его половину блоки по $k$ из массива, делаем $k$-тую порядковую статистику, повторяем
]

#task(numbering: (..) => numbering("1", 4))[]
#solution()[
  #todo()
  Бин поиск по $alpha$:
  $ F(p) frac(sum a_(p_i), sum b_(p_i)) -> frac(sum (a_(p_i) + alpha b_(p_i)), sum b_(p_i)) = F(p) + alpha $
  по условию $exists p, frac(sum a_(p_i), sum b_(p_i)) >= 0$, что эквивалентно $exists p, sum a_(p_i) >= 0$. Выбираем $k$ максимумов из $a$.
]

#task(numbering: (..) => numbering("1", 5))[]
#solution()[
  #todo()
  Подбрасываем для каждого элемента монетку $1 / n$. По индукции
  $ frac(1, n - 1) dot frac(n - 1, n) = frac(1, n) $
]

#task(numbering: (..) => numbering("1", 6))[]
#solution()[
  Подберем такое $k$, сколько раз надо запустить алгоритм:
  $ 
    1 - (1 - frac(1, log n))^n >= 1 - 1 / n \
    (1 - 1 / (log n))^(log n k / (log n)) <= 1 / n \
    #todo()
  $
]

#task(numbering: (..) => numbering("1", 7))[]
#solution()[
  Посмотрим на дерево рещения, там развилки двух типов: сравнение и рандом.
  #todo()
]
