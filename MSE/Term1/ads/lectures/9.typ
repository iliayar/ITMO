#import "../../../../other/typst/lecture_mse.typ": *

#show: doc => lecture(
  subj: [Алгоритмы и структуры данных],
  title: [Лекция 9],
  date: [19 ноября],
  number: 9,
  program: "ITMO MSE y2024",
  doc
)

Есть три подхода к решениею задач:
- Жадность
- Перебор
- Динамика

#example()[
  Задача комивояжера -- найти гамильтогов путь минмальный по весу.
  - Перебор пробует все варианты куда пойти дальне
  - Динамика также перебирает, но еще и запоминает. Т.е. состояние перебора характеризуется только набором уже пройденных вершин
  - Жадник пойдет в самую ближайшую вершину
]

= Непрерывный рюкзак
У каждого предмета также есть стоимость и вес, но предметы можно пилить. Можно отсортировать в порядке $frac("cost"_i, w_i)arrow.b$.

= Дедлайны
Есть задачи, у которых есть дедлайн $d_i$ и время выполнения $t_i$. Нужно выполнять по увеличению дедлайна.

#remark([Как придумывать и доказывать])[
- Попытаться подумать какую задачу нужно выполнить первый, а какую можно выполнить последней.
- Попытаться подумать какую задачу можно выполнить последней.
- Попробовать решить для $n = 2$ или $3$.
Доказательство почти всегда от противного -- пусть сущесвует другой ответ. Пытаемся превратить другой ответ в тот, который придумали, показать наш ответ не хуже.
]

= Задачи

1. Есть множество точек на прямой, нужно точки покрыть отрезками единичной длины. \
   _Решение_: Смотрим самую левую непокрытую точку, ставим отрезок туда его левым концом.
2. На прямой даны отрезки и точки. Для каждой точки узнать сколько отрезков ее покрывают. \
   _Решение_: Идем слева направо по прямой, может произойти:
   - Отрезок начался -- увеличиваем кол-во отрезков на 1
   - Отрезок кончился -- уменьшаем кол-во отрезков на 1
   - Встретили точку -- знаем количесвто отрезков
3. Есть много заявок вида: с момента времени $L_i$ по момент времени $R_i$ занять аудиторию. Нужно выбрать максимальное кол-во заявок которые можем удовлетворить. \
   _Решение_: Рассомтрим ответ: Самый левый отрезок это отрезок это отрезок с минимальным $R_i$ (потому что если есть другой, то можем взять его и ответ не ухудшится). Сортировка по правому концу.
4. То-же самое но $k$ аудиторий. \
   _Решение_: Идем слева направо обрабатываем события:
   - Встретили левую границу отрезка -- берем этот отрезок. Если больше не можем брать, выкидываем отрезок с наибольшей правой границей.
5. Дано дерево, найти максимальное независимое множество. \
   _Решение_: Возьмем листься, по индукции (без листьев и их родителей) возьмем листья и т.д.

= Алгоритм Хафмана

Архивация: $"text" mapsto f("text")$, где $f$ обратима.
1. Не существует идеального архиватора: Рассмотрим все битовые строки длины $k$. Их всего $2^k$. Предположим что все строки получилось сжать, то длина сжатого $0, ..., k-1$. Значит их всего $2^0 + 2^1 + dots 2^k < 2^k$, значит какой-то текст не сожмется.
2. $forall f, exists f'$, такой что если $|f(x)| < |x|$, то он выдает $\"0 f(x)\"$, иначе $\"1 x\"$.

Хотим каждому символу дать битовый код. $A -> 0, B -> 11, C -> 10$. Можем однозначно декодировать если никакой код не является префиксом другого кода. Для каждого символа есть количество раз, которое она встречается в тексте $"cnt"_A$. И соответсвие символов, коду $"code"_A$. 
$ sum_A |"code"_A| dot "cnt"_A -> min $

Как архивируем:
- Выписываем коды
- Выписываем текст, заменяя символы на их код

Как разархивируем:
- Прочитали коды, сложили в бор:
- Идем по тексту и спускаемя по дереву, пока не дойдем по символа, и т.д.

Как построить оптимальные коды: Достаточно знать только количество для каждого символа. Возьмем две самые маленькие $"cnt"_i, "cnt"_j$ и объединяем их, подвешивая их к одному родителю. По получившемуся дереву определяем коды для символов.

#proof[
  Если упорядочем символы по возрастанию количества, то их глубина в дереве будет упорядочена по убыванию. Рассмотрим самый глубокий лист, у него есть брат, значит у них самые маленькие частоты.
]

= Динамика по профилю

Замостить доминошками $2 times 1$ поле $w times h$. Идем слева направо, сверху вних. Очередную клетку можно покрыть поставив доминошку вертикально или горизонтально. Рекурсивно получаем $O(2^(frac(w dot h, 2)))$. Хотим найти количество способов.

#todo()

= Алгоритм Хиршберга

Решаем наибольшую общую подпоследовательность. Если хотим восстанавливать ответ, нужно $O(n^2)$ памяти.
Запустим динамику с двух концов, которые встретятся в $i = frac(n, 2)$.

#todo()
