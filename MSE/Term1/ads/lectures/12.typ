#import "../../../other/typst/lecture_mse.typ": *

#show: doc => lecture(
  subj: [Алгоритмы и структуры данных],
  title: [Лекция 12],
  date: [10 декабря],
  number: 12,
  doc
)

= Графы
== BFS

- Кратчайший путь в графе с невзвешенными ребрами $w_e = 1$.

#remark()[
  BFS по слоям $A_d$:
  #pseudocode-list()[
    - *for* $i in {0, ...}$
      - *for* $v in A$
        - *for* $e : v -> x$
          - *if* $d_x = -1$
            - $A_(i + 1) <- A_(i + 1) union angle.l x angle.r$
            - $d_x <- i + 1$
  ]
]

== Dijkstra

#remark()[
  *SSSP* - Single Source Shortest Path
]

Очередь с приоритетом по расстоянию до вершины.
#todo()

#proof[
  #todo()
]

#remark()[
  $"Time" = V dot "ExtractMin" + E dot "DecreaseKey"$
  - Без кучи: $V dot V + E dot 1$ --- лучше в плотном, т.к. $E ~ V^2$
  - С кучей: $V dot log V + E dot log V$ --- лучше в разреженном

  #todo()
]

== Двусторонняя Дейкстра
Чаще решаем задачу найти кратчайший путь из $A$ в $B$. Можеш параллельно пойти из двух концов. Есть две кучи для $A$ и для $B$, достаем минимум из каждой и идем в ту, которая меньше. Или можно с одной кучей, но храним для каждой вершины откуда мы из нее пришли.

== A\*

Также хотим найти минимальный путь из $s$ в $t$. Имеем фукнцию оценки расстояния до $t$: $f(v) <= d(v, t)$. Используем в Дейкстре в качестве ключа не $d(v)$, а $d(v) + f(v)$.

#example()[
  Если вершины это точки на плоскости, то в качестве $f(v)$ можно использовать Евклидово расстояние от точки $v$ до точки $t$.
]
