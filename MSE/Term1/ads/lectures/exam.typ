#import "../../../../other/typst/lecture_mse.typ": *

#show: doc => lecture(
  subj: [Алгоритмы и структуры данных],
  title: [Вопросы к экзамену],
  date: [23 января],
  number: 0,
  program: "ITMO MSE y2025",
  doc
)

#let theormin = [
  #h(-50pt - 7pt)#text(green)[`(a)`]#h(28pt + 7pt)
]

#let section(body) = [
  #h(16pt)#text(rgb(0,0,255), size: 16pt, weight: "bold")[#body]
]

= Вопросы
#section[Асимптотика]
== Хорошесть алгоритма: асимптотика; константа; память, кеш; простота идеи, реализации.
== #theormin Определения: $cal(O)(n)$, $Theta(n)$.
== Определения: $o(n)$, $Omega(n)$, $omega(n)$.
== Упражнения на понимание: $cal(O)(Theta(cal(O)(f)))$, $o(cal(O)(Theta(f )))$, $Omega(Theta(cal(O)(f)))$.
== Упражнения на доказательства: $cal(O)(cal(O)(f)) = cal(O)(f)$, $cal(O)(C dot f) = cal(O)(f)$, $f + o(f ) = Theta(f)$.
== Стандартные времена работы: полилог, полином, экспонента.
== Время работы цикла for для чисел Фибоначчи. $Theta(n)$, $Theta(n^2)$.
== Модели вычислений: RAM, RAM-w, $log n <= w$, bitset, сложение массивов за $cal(O)(1)$.
== Асимптотика времени работы `for i for j in range(i)` и `for i for j in range(0,n,i)`. Оценка $sum 1 / i = Theta(log n)$.
#section[Элементарные структуры данных]
== Массив обыкновенный. Интерфейс.
== Односвязный список `(head, x, next)`. Интерфейс.
== Двусвязный список. Интерфейс.
== Вектор. Аллокация с удвоением. Интерфейс.
== Циклический массив. Аллокация с удвоением.
== #theormin Интерфейсы стек/очередь/дек.
== Сравнение реализаций стека/очереди/дека через циклический массив и список.
== Амортизационный анализ. Метод потенциалов, анализ вектора.
== Очередь на двух стеках. Очередь с минимумом. Анализ через потенциалы.
== _Дек с минимумом. Анализ через потенциалы._
== _Два указателя: отрезок фиксированной суммы; отрезок min длины с k различными._
#section[Метод разделяй и властвуй]
== #theormin MergeSort. Собственно сортировка.
== MergeSort. Подсчёт числа инверсий в массиве.
== Рекуррентные соотношения, дерево рекурсии, док-во времени работы MergeSort $cal(O)(n log n)$.
== Рекуррентные соотношения: $T (n) = T ( n^2 )+n, T (n) = 3T ( n^2 )+n$, обобщение до Мастер-Теоремы.
== #theormin Двоичный поиск: каноничная 0011-версия.
== Двоичный поиск: сведение задач `lowerBound`, `sqrt(x)` к 0011-версии.
== Двоичный поиск: сколько раз число встречается на отрезке? за $cal(O)(log n)$.
== Двоичный поиск по ответу: отправка коров в стойла так, чтобы $min "dist" -> max$.
== #theormin Умножение многочленов: $cal(O)(n^2)$.
== Умножение многочленов: рекурсия за $cal(O)(n^2)$, Карацуба за $cal(O)(n^(log 3))$.
== Умножение чисел: сведение к многочленам, переносы.
#section[Сортировки и куча]
== Нижняя оценка на сортировки: $Omega(n log n)$ сравнений.
== _Нижняя оценка на время сортировки, корректной для $1 / 100^n $ доли перестановок: $Omega(n log n)$._
== InsertionSort, оценка времени работы $cal(O)(n + #[число инверсий])$.
== SelectionSort, преимущество над всеми другими сортировками.
== #theormin Куча: интерфейс (extractMin, add). Сортировка кучей.
== Бинарная куча: хранение, siftUp, siftDown, add, extractMin.
== Бинарная куча: построение за $cal(O)(n)$, оценка времени.
== _Бинарная куча: поддержка медианы массива с помощью кучи._
== Inplace версия сортировки кучей (без доппамяти).
== Куча: decreaseKey, deleteAny, обратные ссылки.
== C++: `prioirity_queue`, `set`; python: `heapq.heappush`.
#section[Сортировки-2]
== Понятие вероятностного алгоритма. Отличие понятий "амортизированно" и "в среднем".
== #theormin QuickSort. Простая реализация с доппамятью.
== QuickSort. Доказательство через оценку числа сравнений $sum_(i,j) 2 / (j−i+1)$.
== QuickSort. Доказательство заменой суммы на интеграл.
== #theormin QuickSort. Inplace partition. Алгоритм.
== QuickSort. Inplace partition. Оценка времени работы.
== QuickSort. Элиминация хвостовой рекурсии и оценка $cal(O)(log n)$ на доппамять.
== QuickSort: IntroSort.
== $k$-ая статистика: heap, $cal(O)(n + k log n)$.
== $k$-ая статистика: одноветочный QuickSort за $cal(O)(n)$, оценка времени работы.
== $k$-ая статистика: детерминированная с делением на кусочки длины 5.
== _$k$-ая статистика: детерминированная с делением на кусочки длины 3 и 7._
== Inplace алгоритмы: reverse, rotate, swap-половинок-массива.
== _Inplace stable partition за $cal(O)(n log n)$._
#section[Сортировки быстрее $n log n$]
== #theormin CountSort, простая версия.
== CountSort для сортировка пар $chevron.l #[key], #[object] chevron.r$. Стабильность.
== #theormin Частичные (префиксные) суммы.
== _Структура для $n$ чисел от $1$ до $k$ за $chevron.l cal(O)(n + k), cal(O)(1) chevron.r$ говорящая "сколько чисел от a до b"?_
== RadixSort. Реализация за $n log_n C$.
== BucketSort для равномерно распределённых вещественных чисел.
== Несколько CountSort-ов в одном: сортировка массивов $A_1, A_2, dots, A_k$ над алфавитом $m$ за $O(m + sum_i |A_i|)$.
== Рекурсивный перебор: рюкзак со стоимостями, решение за $O(2^n)$.
== Рекурсивный перебор: перебор перестановок за $O(n!)$.
== VEB. Куча, которая умеет всё за $log log C$: общее устройство, откуда $log log$ ?
== VEB. Куча, которая умеет всё за $log log C$: add, extractMin, lowerBound.
#section[Динамика-1]
== #theormin Рекуррентные соотношения: $#[fib]_n, C_(n,k)$ (биномиальные), $f[L, R] = min_M f[L, M ] dot f [M, R]$. Решение всех данных рекуррентных соотношений динамикой.
== #theormin Перебор с запоминанием и динамика (subsetsum).
== Задача "калькулятор": из 1 получить $n min$ числом операций $x -> 2x, 3x, x+1$.
== Задача "кролик": число путей кролика $x → x+3 dots x+5$ так, что кролик не попадает в дырку.
== Динамика вперёд, назад, ленивая, граф динамики. Две версии: $"dp"[v]$ : $s ~> v$ и $"dp"[v] : v ~> t$.
== Динамика, как задача на ацикличном графе: число путей в графе, min/max путь. Решение для графа в явном виде.
== #theormin НВП за $cal(O)(n^2)$.
== НВП за $cal(O)(n log n)$.
== НОП за $cal(O)(n^2)$.
== #theormin Рюкзак (subsetsum и knapsack) за $cal(O)(n S)$.
== Восстановление ответа на примерах НВП, НОП, рюкзак: со ссылками, без ссылок.
== _Рюкзак с линией памяти. Версии рюкзака, когда предмет можно брать $1$ или $+infinity$ раз._
== Рюкзак с bitset.
#section[Динамика-2]
== #theormin DP по дереву: размер поддерева, глубина.
== DP по дереву: max-independent-set, _паросочетание_.
== DP на подотрезках: перемножение матриц $A_1, dots, A_n$ за min время.
== Выбор состояния-функции: версия рюкзака $"sumWeight"["sumCost", i]$.
== #theormin Хранение множеств масками. Общий принцип.
== _Операции с множествами за $cal(O)(1)$ : $x in A, A inter B, A union B, A \\ B, A subset.eq B, {0, 1, dots, n−1}$, размер._
== _Операции с множествами за $cal(O)(1)$: найти младший единичный бит._
== #theormin Гамильтонов путь за $O(2^n n^2)$.
== Гамильтонов путь за $O(2^n n)$.
== _Задача SetCover: покрыть множество B минимальным числом $A_i$. Решение за $O(2^(|B|) m)$._
== Пребор пар "множество, подмножество" за $3^n$.
== Решение задачи Vertex Coloring за $cal(O)(3^n)$.
== DP по профилю: замощение доминошками за $O(4^n m)$.
#section[Жадность]
== #theormin Задача. Непрерывный рюкзак. Жадное решение.
== Задача. Выполнение всех заданий к дедлайнам. Строгое доказательство корректности.
== Задача. Покрыть точки на прямой минимальным числом отрезков длины 1.
== Задача. Выбрать максимальное число непересекающихся отрезков на прямой.
== #theormin Метод событий на прямой: для каждой точки узнать, сколькими отрезками она покрыта.
== Метод событий на прямой: жадный выбор заявок для $k$-аудиторий (без док-ва).
== Задача: max-independent-set в деревьях, жадное решение.
== Хаффман. Алгоритм кодирования, декодирования.
== Хаффман. Хранение дерева/частот.
== Хаффман. Доказательство минимальности.
#section[MST и DSU]
== Лемма о безопасном ребре.
== MST, алгоритм Прима, доказательство.
== #theormin MST, алгоритм Прима, реализации за $V^2, E log V$.
== MST, алгоритм Прима, реализации за $E log_(E/V) V$ ($d$-куча).
== MST, алгоритм Краскала, доказательство.
== MST, алгоритм Краскала, реализация, время работы.
== DSU. Система Непересекающихся Множеств. Интерфейс.
== DSU на списках. join-ы за $n log n$, get за $1$.
== DSU на деревьях, меньшее к большему $==>$ join и get за $log n$.
== DSU на деревьях, эвристика сжатия путей.
== DSU на деревьях: две эвристики с помощью одного доп массива.
#section[Графы. DFS.]
== Определения: граф, смежность, инцидентность, орграф, неорграф.
== #theormin Хранение графов: матрица смежности, списки рёбер.
== Хранение графов: set-ы рёбер, сравнение всех трёх способов.
== #theormin dfs: проверка достижимости, поиск компонент.
== dfs: поиск пути, обратный ход рекурсии.
== dfs и DAG: что такое цикл? topsort, времена входа-выхода.
== dfs: поиск цикла в орграфе.
== _dfs: поиск цикла в неорграфе._
== _dfs: покраска в два цвета._
== Дерево dfs: классификация рёбер.
== Дерево dfs: неорграф не содержит перекрёстных рёбер.
== Компоненты сильной связности. Определение, простая проверка сильной связности.
== Компоненты сильной связности: выделение всех компонент, построение конденсации.
== _2-связность: поиск мостов и компонент (dp по дереву)._
== 2-SAT.
#section[Кратчайшие пути]
== #theormin BFS. Две версии: по слоям; с очередью.
== BFS. _Модификация для целых $1-k$ весов за $O(E + k V)$ и $O(E log k)$._
== BFS. _Модификация для вещественных $1-k$ весов._
== BFS. _Модификация для целых $0-1$ весов._
== Дейкстра. Алгоритм и доказательство корректности.
== #theormin Дейкстра. Реализации за $O(n^2)$, $O(m log n)$.
== Реализация на C++/python: `set`, `prioirity_queue`, `operator<`, `heapq.heappush`.
== Дейкстра. Время работы при применении куч: $d$-ичная, VEB, фибоначчиева.
== Дейкстра. Двусторонняя вариация алгоритма.
== Алгоритм A∗. Пример применения.
== Алгоритм A∗. Доказательство корректности, оценка времени работы.
#section[Амортизация]
== _Алгоритм Борувки._
== Skew heap. Алгоритм.
== Skew Heap, доказательство: лёгкие и тяжёлые рёбра, потенциал.
== DSU. Доказательство $log n$ для сжатия путей.
== DSU. Доказательство $log^∗ n$ для двух эвристик.
== Амортизационный анализ: метод монеток (ростовщика) на примере вектора.
== Турнирное дерево (аналог дерева отрезков).
== Списко-куча: `add`, `merge`, `min` за $cal(O)(1)$ и `extractMin` за амортизированный $cal(O)(log n)$
