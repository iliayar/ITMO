#import "../../../other/typst/lecture_mse.typ": *

#show: doc => lecture(
  subj: [Алгоритмы и структуры данных],
  title: [Лекция 11],
  date: [3 декабря],
  number: 11,
  doc
)

= Графы
#remark()[
  - $G = angle.l V, E angle.r$, $n = |V|, m = |E|$
  - Кратные ребра -- несколько ребер между двумя вершинами
  - Инцидентность -- ребро и каждая его вершина
]
#todo()

== DFS

#todo()

- Компоненты связности
  #todo()
- Найти путь
  #todo()

== Топологическая сортировка
Упорядичить по времени выхода при dfs.

== Поиск цикла
#todo()

== Классификация ребер

#definition()[
  - *Древесные* ребра -- ребра, которые лежат в дереве
  - *Обратные* ребра -- идут вверх по дереву (до предка)
  - *Прямые* ребра -- вниз по дереву (до наследника?)
  - *Перекрестные* ребра -- между разными ветками
]

#lemma()[
  Если запустить dfs для неор. графа, то после dfs'а нет перекрестных ребер
]

== 2-Coloring

Будем красить жадно: красим вершину в цвет $x$, пытаемся покрасить ее соседей в цвет $1 - x$, где цвета $0, 1$

== Сильная связность

Как проверить на сильную связность:
- dfs по ребрам -- проверить что все достижыми
- dfs по обратным ребрам -- проверить что из всех достижима

*Конденсация* -- разбиение на компоненты сильной связности. Перебираем вершины в порядке убывания времени выхода. Красим вершины компоненты, идя по обратным ребрам.

== 2-List-Coloring

Для каждой вершины заданы два цвета, в которую ее можно покрасить. Нужно выбарть для каждой вершины в какой из двух цветов ее покрасить.

Выберем какую-то вершину, покрасим ее в какой нибудь цвет. Также покрасим смежные с ней вершины, которые могут быть покрашены в это цвет. Если не получилось, попробуем покрасить в другой цвет.

Сведение к 2-SAT:
- каждой вершине соответсвует соответсвуют утверждения $x_v = 0, x_v = 1$ -- соответственно вершина покрашена в ее первый или второй цвет. Рассмотрим *граф следствий* из этих утверждений, где ребра это следствия что какое что если $x_a = c$, то $x_b = 1 - c$. Таким образом если в этом графе есть цикл, то это противоречие.

== Мосты

#definition()[
  *Мост* -- ребро, при удалении которого увеличивается компонент связности
]

#definition()[
  *2-связность* (реберная) --- двуместное отношение на вершинах, что существует 2 пути не пересекающихся по ребрам
]

Есть компоненты 2-связности и мосты соединяющие эти компоненты. Задача: найти все мосты. Построим дерево с помощью dfs. Хотим проверить что $a -> b$ --- мост, надо проверить что не можем выбраться из поддерева $b$. Посчитаем динамику $f_b$ --- самое верхнее место, куда можно уйти из вершины $b$.
