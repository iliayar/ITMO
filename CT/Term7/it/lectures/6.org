#+setupfile: setup.org
#+TITLE: Лекция 6
#+date: 6 Октября

* Укорочение
#+NAME: Укорочение, выкалывание и расширение кодов_1
#+begin_definition org
Укороченный код полсучается путем выбора кодовых слов исходного кода, содержащих нули на заданных позициях, с последующим удалением этих нулей

Пусть дан \((n, k, d)\) код с порождающей матрицей \(G=(I|A)\). Удалим из порождающей матрицы \(m\) столбцев удиничной подматрицы и соответствующие \(m\) строк.
#+end_definition

#+begin_examp org
\((7, 4, 3)\) совершенный код, эквивалентный коду Хэмминга
#+begin_export latex
\begin{center}
\begin{equation*}
G = \begin{pmatrix}
1 & 0 & 0 & 0 & 1 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 1 & 0 \\
0 & 0 & 0 & 1 & 0 & 1 & 1
\end{pmatrix} \Rightarrow
G' = \begin{pmatrix}
1 & 0 & 1 & 0 & 1 \\
0 & 1 & 1 & 1 & 1
\end{pmatrix}
\end{equation*}
\end{center}
#+end_export

\((5, 2, 3)\) совершенным не является
#+end_examp

* Выкалывание
#+NAME: Укорочение, выкалывание и расширение кодов_2
#+begin_definition org
Выколотый код: удалим из всех кодовых слов заданные символы (как правило, проверочных).

Пусть дана проверочная матрица \((n, k, d)\) кода в форме \(H = (A|-I)\). Удалим из \(H\) \(m\) столбцов единичной подматрицы и соответствующие им \(m\) строк. Если
проявятся линейно зависимые строки, удалим их \(\implies (n - m, \le k, \ge d - m)\) код
#+end_definition

#+begin_examp org
Построение оптимального кода \((10, 3, 5)\).

- Граница Грайсмера: \(N(3, 5) \ge 5 + N(2, 3) \ge 5 + 3 + N(1, 2) = 5 + 3 + 2 = 10\)
- \(C_1\): Код Хемминга \((7, 4, 3)\) может быть укорочен до \((6, 3, 3)\)
- \(C_2\): Код с повторениями \((6, 1, 6)\)
- Конструкция Плоткина \((C_1, C_1 + C_2)\): код \((12, 4, 6)\)
- Выкалывание одного (последнего) символа: код \((11, 4, 5)\)
- Укорочение на один символ: код \((10, 3, 5)\)

#+begin_export latex
\begin{center}
\begin{equation*}
G_{\rm Ham} = \begin{pmatrix}
1 & 0 & 0 & 0 & 1 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 & 1 & 1 \\
0 & 0 & 1 & 0 & 1 & 1 & 0 \\
0 & 0 & 0 & 1 & 0 & 1 & 1
\end{pmatrix} \Rightarrow
\substack{G_1 = \begin{pmatrix}
1 & 0 & 0 & 1 & 0 & 1 \\
0 & 1 & 0 & 1 & 1 & 1 \\
0 & 0 & 1 & 1 & 1 & 0
\end{pmatrix} \\
G_2 = \begin{pmatrix}
1 & 1 & 1 & 1 & 1 & 1
\end{pmatrix}} \Rightarrow \begin{pmatrix}
1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 \\
0 & 1 & 0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 \\
0 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 
\end{pmatrix} \Rightarrow \\
\Rightarrow \begin{pmatrix}
1 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1 \\
0 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 
\end{pmatrix} \Rightarrow \begin{pmatrix}
1 & 0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1 \\
0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\
0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1
\end{pmatrix}
\end{equation*}
\end{center}
#+end_export
#+end_examp

* Расширение кодов
#+NAME: Укорочение, выкалывание и расширение кодов_3
#+begin_definition org
Наиболее распространенный способ -- добавление проверки на четность. \((n, k, d) \Rightarrow (n + 1, k, d')\).

Если минимальное расстояние \(d\) исходного кода нечетно, то минимальное расстояние расширенного кода \(d' = d + 1\).
#+end_definition

#+NAME: Укорочение, выкалывание и расширение кодов_3_examp
#+begin_examp org
\((7, 4, 3)\) код Хемминга
#+begin_export latex
\begin{center}
\begin{equation*}
G = \begin{pmatrix}
1 & 1 & 1 & 0 & 0 & 0 & 0 \\
1 & 0 & 0 & 1 & 1 & 0 & 0 \\
0 & 1 & 0 & 1 & 0 & 1 & 0 \\
1 & 1 & 0 & 1 & 0 & 0 & 1
\end{pmatrix},
H = \begin{pmatrix}
1 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{pmatrix}
\end{equation*}
\end{center}
#+end_export
\((8, 4, 4)\) расширенный код Хемминга
#+begin_export latex
\begin{center}
\begin{equation*}
G' = \begin{pmatrix}
1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\
1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 0 & 1 & 0 & 0 & 1
\end{pmatrix},
H' = \begin{pmatrix}
0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1
\end{pmatrix}
\end{equation*}
\end{center}
#+end_export
#+end_examp

* Каскадный код
Перемежитель таким образов переставляет символы, что последствия ошибочного декодирования одного кода могут быть легко ликвидированы декодером другого кода

#+ATTR_LATEX: :width \textwidth
[[file:6.1.png]]

* Прямое произведение кодов
#+NAME: Прямое произведение кодов
#+begin_definition org
Пусть даны \((n_1, k_1, d_1)\) (кодирование по строчкам) и \((n_2, k_2, d_2)\) (кодирование по столбцам) коды с порождающими матрицами \(G', G''\). Кодовое слово образуется
путем выписывания полученной матрицы по столбцам. \((n_1n_2, k_1k_2, d_1d_2)\) код с порождающей матрицей
#+begin_export latex
\begin{center}
\begin{equation*}
G' \otimes G'' = \begin{pmatrix}
G_{11}'G'' & G_{12}'G'' & \dots & G_{1n_1}'G'' \\
G_{21}'G'' & G_{22}'G'' & \dots & G_{2n_1}'G'' \\
\vdots    & \vdots    & \ddots & \vdots \\
G_{k_11}'G'' & G_{k_12}'G'' & \dots & G_{k_1n_1}' G'' 
\end{pmatrix} \\
R = \frac{k_1k_2}{n_1n_2} < \frac{k_1}{n_1} \cdot \frac{k_2}{n_2}
\end{equation*}
\end{center}
#+end_export
#+end_definition

Код способен исправить многие конфигурации ошибок веса \(> \frac{d_1 d_2}{2} \)
#+begin_rem org
Параллельный алгоритм кодирования
#+end_rem

\todo Картинка
# https://youtu.be/GXp9DfedPVg?list=PLd7QXkfmSY7YEom7j8DGk8EBw5O5SZDQs&t=1188

#+begin_examp org
Код Рао-Редди \((48, 31, 8)\)

Используется РЖД в рельсовых цепях сигнализации. Прямое произведение расширенного \((16, 11, 4)\) \(C_1\) кода Хемминга и \((3, 2, 2)\) кода \(C_2\) с проверкой на четность \(\implies (48, 22, 8)\).
#+begin_rem org
Кодовые слова имеют вид \((c_1, c_2, c_1 + c_2), c_1, c_2 \in C_1\)
#+end_rem

Дополнение кодовыми словами (с дописанными в конец 32 нулями) кода Рида-Маллера \((16, 5, 8)\) \(C_3\)
#+begin_rem org
Кодовые слова имеют вид \((c_1 + c_3, c_2, c_1 + c_2), c_1, c_2 \in C_1, c_2 \in C_3\). Вес ненулевого кодового слова имеют вид \((c_1 + c_3, c_2, c_1 + c_2)\):
- \(c_3 = 0 : {\rm wt}((c_1, c_2, c_1 + c_2)) \ge 8\)
- \(c_3 \neq 0 : {\rm wt}((c_1 + c_3, c_2, c_1 + c_2)) = {\rm wt}(c_1 + c_3) + {\rm wt}(c_2) + {\rm wt}(c_1 + c_2) \ge {\rm wt}((c_1 + c_3) + (c_2) + (c_1 + c_2)) = {\rm wt}(c_3) \ge 8\)
Получен код \((48, 27, 7)\)
#+end_rem

Пусть \(C_1\) -- код с порождающей матрицей
#+begin_export latex
\begin{center}
\begin{equation*}
\left(\begin{array}{cccccccccccccccc}
0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 0
\end{array}\right)
\end{equation*}
\end{center}
#+end_export

Код \((48, 21, 8)\) Рао-Редди состоит из кодовых слова вида \((c_1 + c_3 + c_4, c_2 + c_4, c_1 + c_2 + c_3), c_1, c_2 \in C_1, c_3 \in C_3, c_4 \in C_4\)
#+end_examp

* TODO Лестничные коды
* Каскадные коды
Закодируем данные внешним \((N, K, D)\) кодом над \(GF(q^k)\)
#+begin_rem org
Строить хорошие коды над \(GF(q^k), k > 1\) проще, чем над \(GF(q)\)
#+end_rem

#+begin_examp org
код Рида-Соломона с \(D = N - K + 1\)
#+end_examp

Представим символы кодового слова как векторы длины \(k\) над \(GF(q)\). Закодируем каждый символ \((n, k, d)\) внутренним кодом над \(GF(q)\). \((Nn, Kk, Dd)\) код над \(GF(q)\). Существуют каскадные коды, достигающие предела Шеннона для воичного симметричного канала

** Граница Зяблова
Выберем внутренний \((n, k, d)\) код на границе Варшамова-Гилберта с \(r = \frac{k}{n} \ge 1 - h\left(\frac{d}{n}\right) = 1 - h(\delta)\). Внешний \((N, K, D = N - K + 1)\) код Рида-Соломона с \(R = 1 - \frac{D - 1}{N} \approx 1 - \Delta\). Сущесвтует код со скоростью \(\rho = Rr\) и относительными расстоянием
\[ \bar{\delta} = \frac{Dd}{Nn} = \Delta\delta \ge (1 - R)(1 - h^{-1}(r)) = \left(1 - \frac{\rho}{r}\right)(1 - h^{-1}(r)) \]
\[ \bar{\delta} \ge \max_{0 \le r \le h (\bar{\delta})} \left(1 - \frac{\rho}{r}\right)(1 - h^{-1}(r)) \]
Далеко не все семейства кодов при длине \(\to \infty\) одновременно обеспечивают скорость \(\rho > 0\) и относительное минимальное расстояние \(\bar{\delta} > 0\)

** Обобщенные каскадные коды
#+NAME: Обобщенные каскадные коды
#+begin_definition org
Внешние \((N_i, K_i, D_i)\) коды \(\mathcal{A}_i\) над \(GF(q^{m_i}), 1 \le i \le s\).
#+end_definition

#+NAME: Обобщенные каскадные коды_rem
#+begin_rem org
Вложенные внутренние \((n_i, k_i, d_i)\) коды \(\mathcal{B}_i : B_1 \supset \mathcal{B}_2 \supset \dots \supset \mathcal{B}_s\) над \(GF(q)\)
- \(k_i - k_{i+1} = m_i\)
- Код \(\mathcal{B}_i\) порождается последними \(k_i\) строками \(k_1 \times n\) матрицы \(B\)

Кодирование:
- Закодируем данные внешними кодами и запишем полученные кодовые слова в \(s \times N\) матрицу \(X\)
- Заменим элементы \(i\)-ой строки \(X\) на их векторное представление (столбец длиной \(m_i\)). Пусть \(Y\) -- полученная \(k_1 \times N\) матрица
- Умножим каждый столбец \(Y\) на \(B\) (т.е. закодируем в коде \(\mathcal{B}_1\))
- Полученная \(n \times N\) матрица может рассматриваться как кодовое слово

Линейный \((Nn, \sum_{i=1}^s K_i m_i, \ge \min_{1 \le i \le s} d_iD_i)\) код над \(GF(q)\). Некоторые ОКК (полярные коды) достигают предела Шеннона.

\todo Картинка
# https://youtu.be/GXp9DfedPVg?list=PLd7QXkfmSY7YEom7j8DGk8EBw5O5SZDQs&t=2940

- Запишем принятые символы в виде \(n \times N\) матрицы
- =for i=1,= \(\dots\) =, s=
  - Продекодируем столбцы в коду \(\mathcal{B}_i\)
  - Продекодируем \(i\)-ую строку в коде \(\mathcal{A}_i\). Пусть \((c_i,\dots, c_N)\) -- найденное кодовое слово
  - Вычтем из \(j\)-ого столбца \(c_jB_i^T\)
#+end_rem

* Турбо коды
#+NAME: Турбо-коды
#+begin_definition org
Одновременное кодирование информационных битов нескольких сверточными кодами позволяет исключить многие конфигурации ошибок, которые могли бы возникнуть при использовании
независимых сверточных кодов. Должны использоваться рекурсивные систематические сверточные коды. Многие информационные последовательности маого веса превращаются в кодовые
слова большого веса. Длина кодового ограничения должна быть небольшой. Кодам с большим кодовым ограничением присущи длинные пакеты ошибок декодирования. Турбо-код является
линейным блоковым кодом. Для повышения скорости кода используется выкалывание

Одновременное кодирование информационных битов нескольких сверточными кодами позволяет исключить многие конфигурации ошибок, которые могли бы возникнуть при использовании
независимых сверточных кодов. Должны использоваться рекурсивные систематические сверточные коды. Многие информационные последовательности маого веса превращаются в кодовые
слова большого веса. Длина кодового ограничения должна быть небольшой. Кодам с большим кодовым ограничением присущи длинные пакеты ошибок декодирования. Турбо-код является
линейным блоковым кодом. Для повышения скорости кода используется выкалывание

Минимальное расстояние
\todo Картинка
# https://youtu.be/GXp9DfedPVg?list=PLd7QXkfmSY7YEom7j8DGk8EBw5O5SZDQs&t=3344

\todo Картинка
# https://youtu.be/GXp9DfedPVg?list=PLd7QXkfmSY7YEom7j8DGk8EBw5O5SZDQs&t=3512

Декодеры сверточных кодов входящих в турбо-код, обмениваются информацией, полученной в результате декодирования. Как правило, достаточно \(5-10\) итераций. Апостериорные логарифмические отношение правдоподобия информационных символов, вычисленные одним
декодером, являются априорными ЛОПП для другого декодера. Аппроксимация декодера максимального правдоподобия. Этот подход применим и для декодирования прямого произведения кодов
#+end_definition

** Алгоритм Бала-Коке-Елинека-Равина декодирования светочных кодов
- Прямая рекурсия \(\alpha_i'(s) = \frac{\sum_{\tilde{s} \in V_{i-1}} \alpha_{i-1}(\tilde{s}) \gamma_{i}(\tilde{s}, s)}{\sum_{s' \in V_i} \sum_{\tilde{s} \in V_{i-1}} \alpha_{i-1}(\tilde{s}) \gamma_i(\tilde{s}, s')} \), \(0 < i \le n\)
- Обратная рекурсия \(\beta_i'(\tilde{s}) = \frac{\sum_{s \in V_{i+1}} \gamma_{i+1}(\tilde{s}, s) \beta_{i+1}'(s)}{\sum_{s \in V_i} \sum_{s' \in V_{i+1}} \alpha_{i}'(s') \gamma_{i + 1}(s', s)} \), \(0 \le i < n\)
- Вычисление апостериорных ЛОПП \(L_i = \ln \frac{\sum_{(s', s) \in S_1} \alpha_i'(s') \gamma_{i+1}(s', s), \beta_{i + 1}'(s)}{\sum_{(s', s) \in S_0} \alpha_i'(s') \gamma_{i+1}(s', s) \beta_{i + 1}'(s)} \)
- Вероятности переходов (для кода со скоростью \(1/2\))
  #+begin_export latex
  \begin{center}
  \begin{align*}
  \gamma_{i+1}(s', s) & = p(s_{i+1} = s, y_{2i}, y_{2i + 1} | s_i = s') = P\{s_{i + 1} = s | s_i = s'\} p(y_{2i}, y_{2i + 1} |s_i = s', s_{i+1} = s) =  \\
  & = P\{u_i = \delta(s', s)\}p(y_{2i}, y_{2i + 1} | (c_{2i}, c_{2i + 1}) = \Delta(s', s))
  \end{align*}
  \end{center}
  #+end_export
  - \(P\{u_i = \delta(s', s)\}\) -- априорная вероятность того, что информационный символ \(u_i\) принимает значение, соответствующее метке перехода \(\delta(s', s) \in \{0, 1\}\). В турбо-декодере эту вероятность вычисляет второй компонентный декодер
  - \(\Delta(s', s)\) -- пара символов, формируемая кодером при переходе из состояния \(s'\) в \(s\)

** Декодирование с использованием ЛОПП
- Внешние (extrinsic) ЛОПП \(L_i^e = \ln \frac{P\{u_i = 0\}}{P\{u_i = 1\}} = \lb \frac{P\{u_i = 0\}}{1 - P\{u_i = 0\}}; P\{u_i=0\} = \frac{\exp(L_i^e)}{1 + \exp(L_i^e)}\)
  \[ P\{u_i = a\} = \begin{cases} \frac{\exp(L_i^e)}{1 + \exp(L_i^e)} \exp(L_i^e / 2) & , a = 0 \\ \frac{\exp(L_i^e)}{1 + \exp(L_i^e)} \exp(-L_i^e / 2) & , a = 1 \end{cases} \]
  \[ P\{u_i = a\} = A \exp((-1)^{a} L_i^e / 2) \]

- Пусть \(S_i = \ln \frac{P\{y_i | c_i = 0\}}{P\{y_i | c_i = 1\}}\). Вероятности выходных символов
  \[ p(y_{2i}, y_{2i + 1} | (c_{2i}, c_{2i + 1})) = B \exp \left( \frac{(-1)^{c_{2i}} S_{2i} + (-1)^{c_{2i + 1}} S_{2i + 1}}{2} \right) \]

- Коэффиценты \(A, B\) сокращаются во всех выражениях, используемых в алгоритме БКЕР, а потому могут быть отброшены

Получение внешних ЛОПП: \\
Предположим, что используется систематическое кодирование сверточных кодов и \(c_{2i} = u_i\), где \(u_i\) -- информационные символы. Результатом работы алгоритма БКЕР
являются \(L_i = \ln \frac{P\{u_i = 0 | y_0, \dots, y_{2n - 1}\}}{P\{u_i = 1 | y_0, \dots, y_{2n - 1}\}}\). Для турбо-декодирования необходимо вычислить \(\tilde{L}_i^c = \ln \frac{P\{u_i = 0 | Y_{2i}\}}{P\{u_i = 1 | Y_{2i}\}} \),
\(Y_{2i} = (y_0, \dots, y_{2i - 1}, y_{2i + 1}, \dots, y_{2n - 1}\). Это позволит исключить двойной учет принятых символов (по крайней мере, на первой итерации)
#+begin_export latex
\begin{center}
\begin{align*}
P\{u_i = a | Y_{2i}, y_{2i}\} & = \frac{P\{u_i = a, Y_{2i}, y_{2i}\}}{P(Y_{2i}, y_{2i})} = \frac{P(Y_{2i}, y_{2i} | u_i = a) P\{u_i = a\}}{P(Y_{2i}, y_{2i})} = \\
& = \frac{P(Y_{2i} | u_i = a) P(y_{2i} | u_i = a) P\{u_i = a\}}{P(Y_{2i}, y_{2i})} = \frac{P(Y_{2i} | u_i = a) P(y_{2i} | c_{2i} = a) P\{u_i = a\}}{P(Y_{2i}, y_{2i})}
\end{align*}
\[ L_i = \ln \frac{P\{Y_{2i} | u_i = 0\}}{P\{Y_{2i} | u_i = 1\}} + S_i + L_i^e \]
\end{center}
#+end_export

Различные полуитерации используют различные \(Y_i\), при этом изначально известно, что \(P\{u_i = 0\} = P\{u_i = 1\} = 1/2\). Поэтому \(\tilde{L}_i^c = L_i - S_i - L_i^e\)

Итеративный алгоритм декодирования:
1. Положить \(L_{1 \to 2}^e(u_i) = 0\)
2. Воспользоваться декодером БКЕР для сверточного кодера \(1\)
3. Подвергнуть перемежению  полученные ЛОПП \(\tilde{L}_i^e\) и использовать их как \(L_{1 \to 2}^e (u_i\)
4. Воспользоваться декодером БКЕР для сверточного кодера \(2\)
5. Подвергнуть деперемежению полученные апостериорные ЛОПП \(\tilde{L}_i^e\) и использовать их как \(L_{2 \to 1}^e(u_i)\)
6. Перейти к шагу \(2\), если не превышено максимальное число итераций (\(5 - 10\))

** Построение перемежителей
Требование: близкие позиции во входной последовательности должны отображаться в максимально удаленные позиции в выходной последовательности
\[ 0 < |i - j| < d \implies |\pi(i) - \pi(j)| \ge S \]
Важны объем памяти, требуемый для реализации перемежителя, его задержка. Псевдослучайный перемежитель: случайная генерация с отбрасыванием перестановок с неудовлетворительными \(S, d\)

#+begin_examp org
Табличный перемежитель
#+begin_export latex
\begin{center}
\begin{equation*}
(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) \to \begin{pmatrix}
1 & 2 & 3 & 4 \\
5 & 6 & 7 & 8 \\
9 & 10 & 11 & 12 \\
13 & 14 & 15 & 16
\end{pmatrix} \to \\
\to (13, 9, 5, 1, 14, 10, 6, 2, 15, 11, 7, 3, 16, 12, 8, 4)
\end{equation*}
\end{center}
#+end_export
#+end_examp
Перестановочный полином: если \(Q(x) = \sum_{i_0}^l q_i x^i \mod N\) -- биекция в \(\mathbb{Z}_N\), то перестановка может быть задана как
\(Q(i) \to Q(i + 1\)
#+begin_examp org
\(Q(x) = \frac{kx(x + 1)}{2} \mod N, k \equiv 1 \mod 2\)
#+end_examp


* Заключение
- Длинные коды можно строить из коротких
- Составные коды допускаюи простое декодирование
- Существуют каскадные коды
  - у которых относительное минимальное расстояние положительным при всех скоростях
  - достигающие предела Шеннона для двоичного симметричного канала (1966, Форни)
- Некоторые обобщенные каскадные коды (полярные) достигают предела Шеннона
- Турбо-коды стали первым классом корректирующих кодов, которые смогли на практике приблизится в пределу Шеннона (1993)
