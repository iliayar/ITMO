#+PUBNOTE:html
#+SETUPFILE: ../../level-subj.org
#+title: –ó–∞–º–µ—Ç–∫–∏ –∫ —ç–∫–∑–∞–º–µ–Ω—É
#+OPTIONS: num:nil
* TODO –õ–µ–∫—Ü–∏—è 0
* TODO –õ–µ–∫—Ü–∏—è 1
* TODO –õ–µ–∫—Ü–∏—è 2
* TODO –õ–µ–∫—Ü–∏—è 3
* TODO –õ–µ–∫—Ü–∏—è 4
* TODO –õ–µ–∫—Ü–∏—è 5
* TODO –õ–µ–∫—Ü–∏—è 6
* –õ–µ–∫—Ü–∏—è 7
#+begin_src haskell
class Applicative m => Monad m where
  return :: a -> m a                -- return
  (>>=) :: m a -> (a -> m b) -> m b -- bind
#+end_src

–î–ª—è ~Maybe~:
#+begin_src haskell
instance Monad Maybe where
  return = Just

  Nothing >>= _ = Nothing
  Just a >>= f = f a
#+end_src

–ü—Ä–∏–º–µ—Ä –¥–ª—è ~Identity~
#+begin_src haskell
newtype Identity a = Identity { runIdentity :: a } 
#+end_src
–ò–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã —Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã–π

–ü—Ä–∏–º–µ—Ä –¥–ª—è ~Either~
#+begin_src haskell
instance Monad (Either e)  where
  --snip--
#+end_src
*NB*: –ó–¥–µ—Å—å —Ç–∏–ø ~e~ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω—ã–π –¥–ª—è –æ–¥–Ω–æ–≥–æ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–æ–≥–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è

–ö–æ–º–ø–æ–∑–∏—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –º–æ–Ω–∞–¥:
#+begin_src haskell
(<=<)  :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
(>=>)  :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
#+end_src

- ~m >>= (f >=> g) ‚â° m >>= f >>= g~
- ~m >>= (f <=< g) ‚â° m >>= g >>= f~
- –ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å

–ü—Ä–∏–º–µ—Ä –º–æ–Ω–∞–¥—ã ~[]~
#+begin_src haskell
instance Monad [] where
  return x = [x]

  l >>= f = concat (map f l)
#+end_src


#+begin_src haskell
(>>)  :: Monad m => m a -> m b -> mb
m >> k = m >>= \_ -> k
#+end_src

–ü—Ä–∏–º–µ—Ä
#+begin_src haskell
ghci> [True, False]  >> [1, 2, 3]
[1, 2, 3, 1, 2, 3]
#+end_src



~guard~ –¥–ª—è —Å–ø–∏—Å–∫–∞
#+begin_src haskell
guard :: Bool -> [()]
guard True  = [()]
guard False = []
#+end_src

–ü–æ–ª–∏–º–æ—Ä—Ñ–Ω–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞
#+begin_src 
guard :: (Alternative f) => Bool -> f ()
#+end_src

–ë–µ—Å–ø–æ–ª–µ–∑–Ω—ã–π –ø—Ä–∏–º–µ—Ä
#+begin_src haskell
ghci> [True, False, True]  >> [1, 2]
[1, 2, 1, 2, 1, 2]
ghci> [True, False, True] >>= \b -> guard b >> [1, 2]
[1, 2, 1, 2]
#+end_src


#+begin_src 
join :: Monad m => m (m a) -> m a
#+end_src

–ù–µ–ª—å–∑—è –Ω–∞–ø–∏—Å–∞—Ç—å –≤–∞–ª–∏–¥–Ω—ã–π –∏–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã üò≠
#+begin_src haskell
data BarBaz a = Bar a | Baz a a 
#+end_src


#+begin_src haskell
liftM :: Monad m => (a -> b) -> m a -> m b
#+end_src

–ê–ª—å—Ç–µ—Ä–Ω–∏—Ç–≤–Ω—ã–µ –±—É–ª–µ–≤—Å–∫–∏–µ –æ–ø—Ä–µ—Ä–∞—Ç–æ—Ä—ã
#+begin_src haskell
(||^), (&&^) :: m Bool -> m Bool -> m Bool
#+end_src


–ó–∞–∫–æ–Ω—ã –º–æ–Ω–∞–¥
1. ~return a >>= f  ‚â° f a~
1. ~m >>= return    ‚â° m~
1. ~(m >>= f) >>= g ‚â° m >>= (\x -> f x >>= g)~

–ú–æ–∂–µ–º –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –¥–æ–∫–∞–∑–∞—Ç—å –∑–∞–∫–æ–Ω—ã —Ä—É–∫–∞–º–∏
* –õ–µ–∫—Ü–∏—è 8
** Writer
#+begin_src haskell
newtype Wrtier w a = Writer { runWriter :: (a, w) }  -- a is value, w is log

instance Monoid w => Moand (Writer w) where
  return a = Writer (a, mempty)

  Writer (a, oldLog) >>= f = let Wrtier (b, newLog) = f a
                             in Writer (b, oldLog <> newLog)
#+end_src


–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src haskell
tell       :: w -> Writer w ()
execWriter :: Writer w a -> w
writer     :: (a, w) -> Writer w a
#+end_src

- –ï—Å—Ç—å –∏–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã –¥–ª—è –ø–∞—Ä—ã, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ ~Writer~
- ~Writer~ –Ω–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π, –∫—É—à–∞–µ—Ç –º–Ω–æ–≥–æ –ø–∞–º—è—Ç–∏

** Reader

#+begin_src haskell
newtype Reader e a = Reader { runReader :: e -> a } -- e is environment

instance Monad (Reader e) where
  return a = Reader $ \_ -> a

  m >>= f = Reader $ \r -> runReader (f $ runReader m r) r
#+end_src

–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src haskell
ask   :: Reader e e
asks  :: (e -> a) -> Reader e a
local :: (e -> b) -> Reader b a -> Reader e a
#+end_src


*Note*: Typed holes ‚Äî ~foo x = _x~

** State

#+begin_src haskell
newtype State s a = State { runState :: s -> (a, s) } 

instance Monad (State s) where
  return a = State $ \s -> (a, s)

  oldState >>= f = State $ \s -> let (a, newState) = runState oldState s
                                 in runState (f a) newState
#+end_src


–ü—Ä–∏–º–µ—Ä –¥–ª—è —Å—Ç–µ–∫–∞
#+begin_src haskell
type Stack = [Int]

pop :: State Stack Int
pop = State $ \(x:xs) -> (x, xs)

push :: Int -> State Stack ()
push x = State $ \xs -> ((), x:xs)
#+end_src

–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src haskell
get       :: State s s
put       :: s -> State s ()
modify    :: (s -> s) -> State s ()
gets      :: (s -> a) -> State s a
withState :: (s -> s) -> State s a -> State s a
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
#+end_src



–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –º–æ–Ω–∞–¥–æ–≤
#+begin_src haskell
replicateM :: Moad m => Int -> m a -> m [a] 

forM_ :: (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
#+end_src

** Cont
#+begin_src haskell
addCPS :: Int -> Int -> ((Int -> r) -> r)
addCPS x y = \k -> k (x + y)
#+end_src

#+begin_src haskell
newtype Cont r a = Cont { runCont :: (a -> r) -> r } 
#+end_src

* –õ–µ–∫—Ü–∏—è 9

–ü–æ—á–µ–º—É –Ω–µ –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç –≤–≤–æ–¥ —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–π
#+begin_src haskell
getChar :: Char 
get2Char :: [Char]
get4Char :: [Char]
#+end_src

–ò—Å–æ–ø–ª—å–∑—É–µ–º —á—Ç–æ-—Ç–æ –≤—Ä–æ–¥–µ
#+begin_src haskell
getChar :: RealWorld -> (Char, RealWorld) 
get2Char :: ReadWorld -> ([Char], RealWorld)
get4Char :: ReadWorld -> ([Char], RealWorld)
#+end_src


~do~ –Ω–æ—Ç–∞—Ü–∏—è

–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src 
sequence_ :: [IO a] -> IO ()
#+end_src

~return~ –Ω–µ —Ç–æ —á–µ–º –∫–∞–∂–µ—Ç—Å—è

–õ–µ–Ω–∏–≤–æ—Å—Ç—å —Å —Ñ–∞–π–ª–∞–º–∏

FFI, ~IORef~, ~IOArray~, ~IOException~, ~unsafePerformIO~

~OverloadedStrings~

~Text~, ~ByteString~ –∏—Å–ø–æ–ª—å–∑—É—é—Ç ~unsafe~ –æ–ø–µ—Ä–∞—Ü–∏–∏, –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –±–µ–∑–æ–ø–∞—Å–Ω–æ

* –õ–µ–∫—Ü–∏—è 10
#+begin_src haskell
newtype Parser a = Parser { runP :: String -> Maybe (a, String) } 
#+end_src


–î–µ–ª–∞–µ–º –ø—Ä–æ—Å—Ç—ã–µ –ø–∞—Ä—Å–µ—Ä—ã, –∫–æ–º–±–∏–Ω–∏—Ä—É—è –∏—Ö –ø–æ–ª—É—á–∞–µ–º –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ

#+begin_src haskell
ok :: Parser ()
ok = Parser $ \s -> Just ((), s)

isnot :: Parser a -> Parser ()
isnot parser = Parser $ \s ->
  case runP parser s of
    Just _  -> Nothing
    Nothing -> Just ((), s)

eof :: Parser ()
eof = Parser $ \s ->
  case s of
    [] -> Just ((), "")
    _  -> Nothing


satisfy :: (Char -> Bool) -> Parser Char
satisfy p = Parser $ \s ->
  case s of
    [] -> Nothing
    (x:xs) -> if p x then Just (x, xs) else Nothing

notok :: Parser ()
notok = isnot ok

char :: Char -> Parser Hcar
char c = satisfy (== c)

--snip--

instance Functor Parser where
  fmap f (Parser parser) = Parser (fmap (first f) . parser)

instance Applicative Parser where
  pure a = Parser $ \s -> Just (s, s)

  Parser pf <*> Parser pa = Praser $ \s ->
    case pf s of
      Nothing -> Nothing
      Just (f, t) -> case pa t of
        Nothing -> Nothing
        Just (a, r) -> Just (f a, r)


instance Monad Parser where
  return = pure

  p >>= f = Parser $ \s ->
    case runP p s of
      Nothing -> Nothing
      Just (a, t) -> runP (f a) t

instance Aternative Parser
  --snip--
#+end_src

* –õ–µ–∫—Ü–∏—è 11
** Unit testing ‚Äî ~HSpec~
–ú–æ–∂–µ—Ç —Å–∞–º –∏—Å–∫–∞—Ç—å —Ç–µ—Å—Ç—ã –≤ –º–æ–¥—É–ª—è—Ö —Å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º ~spec~?

- ~shouldSatisfy~ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ –ø—Ä–µ–¥–∏–∫–∞—Ç—É
- ~shouldBe~ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ

#+begin_src haskell
hspecTestTree :: IO TestTree
hspecTestTree = testSpec "Simple parser" spec_Parser

spec_Parser :: Spec
spec_Parser = do
  describe "eof works" $ do
    it "eof no empty input" $
      runP eof "" `shouldSatisfy` isJust
    it "eof no non-empty input" $
      runP eof "x" `shouldSatisfy` isNothing
  describe "char works" $ do
    it "char parses character" $
      runP (char 'a') "abc" `shouldBe` Just ('x', "bc")
#+end_src

** Property-based ‚Äî ~Hedgehog~
/–ü—Ä–∏–º–µ—Ä/: ~‚àÄ xs. reverse (reverse xs) ‚â° xs~

#+begin_src haskell
genIntList :: Gen [Int]
genIntList =
  let listLength = Range.linear 0 10000
  in Gen.List listLength Gen.enumBounded

prop_reverse :: Property
prop_reverse = property $
  forAll genIntList >>= \xs ->
  List.reverse (List.reverse xs) === xs
#+end_src

Shrinking ‚Äî —É–º–µ–Ω—å—à–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ —Ç–µ—Å—Ç–∞ –¥–æ —á–∏—Ç–∞–±–µ–ª—å–Ω–æ–≥–æ –≤–∏–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–≤—Ç–æ—Ä—è–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ

–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—Ä–∞—Ç–Ω—ã—Ö
#+begin_src 
read        . show      ‚â° id
decode      . encode    ‚â° id
deserialize . serialize ‚â° id
#+end_src

–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫–æ–Ω–æ–≤ –º–æ–Ω–æ–∏–¥–æ–≤ –∏ –ø—Ä..
#+begin_src 
(a <> b) <> c ‚â° a <> (b <> c)
a <> mempty   ‚â° a
mempty <> a   ‚â° a
#+end_src

* –õ–µ–∫—Ü–∏—è 12
–ú–æ–∂–µ–º –∫–æ–º–ø–æ–∑–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ç–æ—Ä—ã, –∞–ø–ø–ª–∏–∫–∞—Ç–∏–≤—ã, –∏ —Ç.–¥.
#+begin_src haskell
newtype Compose f g a = Compose { getCompose :: f (g a) }

instance (Functor f, Functor g) => Functor (Compose f g)
instance (Foldable f, Foldable g) => Foldable (Compose f g)
instance (Applicative f, Applicative g) => Applicative (Compose f g)
--snip--
#+end_src
*–ù–æ –Ω–µ –º–æ–Ω–∞–¥*

–î–ª—è ~Maybe~
#+begin_src haskell
newtype MaybeIO = MaybeIO { runMaybeIO :: IO (Maybe a) }

instance Monad MaybeIO where
  return x = MaybeIO (return (Just x))
  MaybeIO action >>= f = MaybeIO $ do
    result <- action
    case result of
      Nothing -> return Nothing
      Just x -> runMaybeIO (f x)
#+end_src

–ü—Ä–æ–±–ª–µ–º–∞
#+begin_src haskell
result <- runMaybeIO $ do
  c1 <- MaybeIO $ tryConnect "host1"
  print "Hello"
  c2 <- MaybeIO $ tryConnect "host2"
#+end_src

~print~ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ ~Maybe~

#+begin_src haskell
transformIO2MaybeIO :: IO a -> MaybeIO a
transformIO2MaybeIO action = MaybeIO $ do
  result <- action
  return (Just result)
#+end_src

–ü–µ—Ä–≤—ã–π —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä
#+begin_src haskell
newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } 

type MaybeIO = MaybeT IO

instance Monad m => Monad (MaybeT m) where
  return x = MaybeT (return (Just x))
  MaybeT action >>= f = MaybeT $ do
    result <- action
    case result of
      Nothing -> return Nothing
      Just x -> runMaybeT (f x)

transformIO2MaybeT :: Functor m => m a -> MaybeT m a
transformIO2MaybeT action = MaybeT . fmap Just
#+end_src


–ö–ª–∞—Å—Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–æ–≤
#+begin_src haskell
class MonadTrans t where
  lift :: Monad m => m a -> t m a
#+end_src
- ~lift . return ‚â° return~
- ~lift (m >>= f) ‚â° lift m >>= (lift . f)~


–ü—Ä–∏–º–µ—Ä –¥–ª—è ~Reader~
#+begin_src haskell
newtype ReaderT r m a = Reader T { runReaderT :: r -> m a }

type Reader r a = ReaderT r Identity a
type LoggerIO a = ReaderT LoggerName IO a
#+end_src

–∏–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã –¥–ª—è ~ReaderT~ –ø–æ—á—Ç–∏ —Ç–∞–∫–æ–π –∂–µ –∫–∞–∫ –∏ –¥–ª—è ~Reader~

*NB* –¢–∞–±–ª–∏—Ü–∞ —Ç—Ä–∞–Ω—Å–æ—Ñ—Ä–º–µ—Ä–æ–≤
| *Base Monad* | *Transormer* | *Original Type*   | *Combined Type*       |
|------------+------------+-----------------+---------------------|
| ~Maybe~    | ~MaybeT~   | ~Maybe a~       | ~m (Maybe a)~       |
| ~Either~   | ~EitherT~  | ~Either a b~    | ~m (Either a b)~    |
| ~Writer~   | ~WriterT~  | ~(a, w)~        | ~m (a, w)~          |
| ~Reader~   | ~ReaderT~  | ~r -> a~        | ~r -> m a~          |
| ~State~    | ~StateT~   | ~s -> (a, s)~   | ~s -> m (a, s)~     |
| ~Cont~     | ~ContT~    | ~(a -> r) -> r~ | ~(a -> m r) -> m r~ |

~IO~ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–æ–º


*–ü—Ä–æ–±–ª–µ–º–∞*: –ï—Å–ª–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–æ–≤ –º–Ω–æ–≥–æ, —Ç–æ –ø—Ä–∏–¥–µ—Ç—Å—è –ø–∏—Å–∞—Ç—å –º–Ω–æ–≥–æ ~lift~

–í—Å–µ –≤—ã—à–µ –≤ –ø–∞–∫–µ—Ç–µ ~transformers~. –ü–∞–∫–µ—Ç ~mtl~ —Ä–µ—à–∞–µ—Ç —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É

#+begin_src haskell
class Monad m => MonadReader r m | m -> r where
  ask :: m r
  --snip--

instance Monad m => MonadReader r (ReaderT r m) where
  --snip--

instance Monad m => MonadReader r (StateT s m) where
  ask = lift ask
  --snip--
#+end_src



#+begin_src haskell
class Monad m => MonadThrow m where
  throwM : Exception e => e -> m a

class MonadThrow m => MonadCatch m where
  catch :: Exception e => m a -> (e -> m a) -> m a
#+end_src

~ThrowError~ ‚Äì –∫–æ–≥–¥–∞ –Ω–∞–¥–æ —Å–ª–æ–º–∞—Ç—å –≤—Å–µ

–ú–æ–∂–µ–º –∏—Å–ø–æ–ª—å–æ–≤–∞—Ç—å ~deriving~ –∏ ~mtl~
#+begin_src haskell
newtype M a = M(ReaderT Environment (StateT MyState IO) a)
  deriving (Functor, Applicative, Monad, MonadIO, MonadState MyState, MonadReader Environment)
#+end_src

- –ó–∞–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å ~IO~ —Ç–æ–ª—å–∫–æ –≤ ~ReaderT~
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –º–æ–Ω–∞–¥—É, –µ—Å–ª–∏ –∫–æ–Ω–µ—á–Ω–æ –Ω–µ –ø–∏—à–∏—Ç–µ –ª–∏–±—É

* –õ–µ–∫—Ü–∏—è 13
[[http://slides.com/fp-ctd/lecture-10#/][–°–ª–∞–π–¥—ã]]

–ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è —Å–ø–∏—Å–∫–æ–≤ –∑–∞ O(1)
#+begin_src haskell
newtype DList a = DL { unDL :: [a] -> [a] }

fromList :: [a] -> DList a
fromList l = DL (l++)

toList :: DList a -> [a]
toList (DL lf) = lf []

append :: DList a -> DList a -> DList a
(DL f) `append` (DL g) = DL $ \xs -> f (g xs) -- append = mappend = <>
#+end_src

–û—Ç–∫–ª–∞–¥—ã–≤–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏–∏, –¥–æ —Ç–µ—Ö –ø–æ—Ä. –ø–æ–∫–∞ –Ω–∞–º –Ω–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è
—Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã—á–∏—Å–ª–∏—Ç—Å—è –∑–∞ –¥–ª–∏–Ω—É —Å–ø–∏—Å–∫–∞, –±–ª–∞–≥–æ–¥–∞—Ä—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É
–ø–æ—Ä—è–¥–∫—É –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ ~++~


–ò–≥—Ä—É—à–µ—á–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è ~seq~ ‚Äî —Ñ–æ—Ä—Å–∏—Ç –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –¥–æ WHNF
#+begin_src haskell
seq :: a -> b -> b
_|_ `seq` _ = _|_
_   `seq` b = b
#+end_src


- ~foldl~, ~foldr~ –º–µ–¥–ª–µ–Ω–Ω—ã–µ
- ~foldl'~ ‚Äî —Å—Ç—Ä–æ–≥–∞—è –≤–µ—Ä—Å–∏—è, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ~seq~

~deepseq~ –∫–∞–∫ ~seq~, –Ω–æ –≤—ã—á–∏—Å–ª—è–µ—Ç –¥–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º—ã. –ß—Ç–æ–±—ã –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä
–∑–Ω–∞–ª, –∫–∞–∫ –≤—ã—á–∏—Å–ª—è—Ç—å –≤–∞—à—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º—ã, –Ω—É–∂–Ω–æ
–∑–∞–∏–Ω—Å—Ç–∞–Ω—Å–∏—Ä–æ–≤–∞—Ç—å ~NFData~
#+begin_src haskell
class NFData a where
  rnf :: a -> ()
  rnf a = a `seq` ()

instance NFData a => NFData (Maybe a) where
  rnf Nothing = ()
  rnf (Just x) = rnf x

instance NFData a => NFData [a] where
  rnf [] = ()
  rnf (x:xs) = rnf x `seq` rnf xs


deepseq :: NFData a => a -> b -> b
a `deepseq` b = rnf a `seq` b
#+end_src

- ~-XBangPatterns~ ‚Äî –º–æ–∂–Ω–æ —Å—Ç–∞–≤–∏—Ç—å ~!~ –ø–µ—Ä–µ–¥ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º —á—Ç–æ–±—ã –≤—ã—á–∏—Å–ª–∏—Ç—å –µ–≥–æ –¥–æ WHNF ‚Äî —Å–∞—Ö–∞—Ä –¥–ª—è ~seq~
- ~-XIrrefutablePatterns~
  #+begin_src haskell
f :: (a, b) -> Int
f (a, b) = const 1 a -- f undefined –ø–∞–¥–∞–µ—Ç

g :: (a, b) -> Int
g ~(a, b) = const 1 a -- g undefined –Ω–µ –ø–∞–¥–∞–µ—Ç
  #+end_src

–ú–æ–∂–µ–º —Ñ–æ—Ä—Å–∏—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π
#+begin_src haskell
data Config = Config
  { user : !Int
  , extra :: !Maybe Settings
  } deriving (Show)
#+end_src

- ~-XStrictData~ ‚Äî —Å—Ç—Ä–æ–≥–∏–µ –ø–æ–ª—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
- ~-XStrict~ ‚Äî —Å—Ç—Ä–æ–≥–æ—Å—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

–ö–æ–≥–¥–∞ —Å—Ç–æ–∏—Ç —Ñ–æ—Ä—Å–∏—Ç—å:
- –ü—Ä–æ–≥—Ä–∞–º–º–∞ –º–µ–¥–ª–µ–Ω–Ω–∞—è –∏–ª–∏ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –¥–∏–º–∏—Ç —Å—Ç–µ–∫–∞
- –ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
- –£–º–µ–Ω—å—à–∏—Ç—å —Ä–æ—Å—Ç –≤—ã–∑–æ–≤–æ–≤
  - ~f x = g$! (h x)~
  - ~f x = g x~
  - ~f !x = g (h x)~
- –ü–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä
* –õ–µ–∫—Ü–∏—è 14
–ü—Ä–æ–±–ª–µ–º–∞: `map f . map g` –º–µ–¥–ª–µ–Ω–Ω–µ–µ —á–µ–º ~map (f. g)~

Deforestataion: –ú–æ–∂–µ–º —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—è, —Å–≤–æ—Ä–∞—á–∏–≤–∞—è —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–∂–µ–º –¥–µ–ª–∞—Ç—å
—ç–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
#+begin_src haskell
func = foldr (+) 0 . map (*10)

func l = case l of
  [] -> 0
  (y:ys) -> 10 * y + func ys
#+end_src


–ò–≥—Ä—É—à–µ—á–Ω—ã–π –ø–æ—Ç–æ–∫
#+begin_src haskell
newtype List a = List ([a] -> Maybe (a, [a]))

map1 : (a -> b) -> List a -> List b
map1 g (List f) = List h
  where
    h s' = case f s' of
      Nothing -> Nothing
      Just (x, s'') -> Just (g x, s'')
#+end_src
*–ü—Ä–æ–±–ª–µ–º–∞*: —Ç–∏–ø—ã –Ω–µ —Å–æ–π–¥—É—Ç—Å—è

–ù–æ—Ä–º –≤–µ—Ä—Å–∏—è
#+begin_src haskell
data List a b = List ([a] -> Maybe (b, [a]))  [a]
#+end_src

#+begin_src haskell
unfoldr :: b -> ([a] -> Maybe (b, [a]))  -> [a]
#+end_src

–î–æ–±–∞–≤–∏–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–∫–∏–ø–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã —Å—Ç—Ä–∏–º–∞
#+begin_src haskell
data Step s a = Done
              | Skip    s
              | Yield a s

data Stream a = forall s. Stream (s -> Step s a) s

stream :: forall a. [a] -> Stream a
stream xs = Stream next xs
  where
    next :: [a] -> Step [a] a
    next [] = Done
    next (x:xs) = Yield x xs

unstream :: forall a. Stream a -> [a]
unstream (Stream next s0) = go s0
  where
    go s = case next s of
             Done -> []
             Skip s' -> go s'
             Yield a s' -> a : go s'
#+end_src


–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src haskell
mapS :: forall a b. (a -> b)-> Stream a -> Stream b
mapS f (Stream next s) = Stream next' s
  where
    next' xs = case next xs of
                 Done -> Done
                 Skip s' -> Skip s'
                 Yield a s' -> Yield (f a) s'

mapS :: forall a. (a -> Bool)-> Stream a -> Stream b
mapS p (Stream next s) = Stream next' s
  where
    next' xs = case next xs of
                 Done -> Done
                 Skip s' -> Skip s'
                 Yield a s' -> if p a then Yield a s' else Skip s'
#+end_src


Rewrite rule:
#+begin_src haskell
map s = unstream . mapS s . stream
filter s = unstream . filterS s . stream

foo = map show . filter even
#+end_src
~foo~ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç—Å—è –≤ ~foo s = unstream . mapS s . stream . unstream . filterS s . stream~
–ú–æ–∂–µ–º –Ω–∞–ø–∏—Å–∞—Ç—å /–ø—Ä–∞–≤–∏–ª–æ/ —á—Ç–æ–±—ã –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–≤–æ—Ä–∞—á–∏–≤–∞–ª ~stream (unstream s)~
#+begin_src haskell
{-# RULES "stream/unstream"
    forall (s :: Stream a). stream (unstream s) = s
#-} 
#+end_src

~ST~ –º–æ–Ω–∞–¥–∞ ‚Äî —á—Ç–æ-—Ç–æ –≤—Ä–æ–¥–µ IO, –Ω–æ –±–µ–∑ –¥–æ—Å—Ç—É–ø–∞ –∫ –≤–Ω–µ—à–Ω–µ–º—É –º–∏—Ä—É
* –õ–µ–∫—Ü–∏—è 15
–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–µ–ª–µ–Ω—ã–µ –ø–æ—Ç–æ–∫–∏, –ø–ª—é—Å –µ—Å—Ç—å —Ç.–Ω. spark'–∏ ‚Äî –µ—â–µ –±–æ–ª–µ–µ
–ª–µ–≥–∫–æ–≤–µ—Å–Ω–∞—è –µ–¥–∏–Ω–∏—Ü–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è


#+begin_src haskell
forkIO :: IO () -> IO ThreadId 
#+end_src

–ú–æ–∂–µ–º —É–∫–∞–∑–∞—Ç—å —Ñ–ª–∞–≥–∏ ~+RTS -N2~ —á—Ç–æ–±—ã –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—ã–ø–æ–ª–Ω—è–ª–∞—Å—å –≤ 2—Ö –ø–æ—Ç–æ–∫–∞—Ö

#+begin_src haskell
data MVar a 
#+end_src
–ú–æ–∂–µ–º –¥–æ—Å—Ç–∞—Ç—å/–ø–æ–ª–æ–∏—Ç—å —Å –æ–∂–∏–¥–∞–Ω–∏–µ–º, –≤–Ω—É—Ç—Ä–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞. –ú–æ–≥—É—Ç –±—ã—Ç—å –≤—ã–∫–∏–Ω—É—Ç—ã –∏—Å–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–π –ø–æ–ø—ã—Ç–∫–µ
–∑–∞–¥–µ—Ç–µ–∫—Ç–∏—Ç—å deadlock.


#+begin_src haskell
throwTo :: Exception e => ThreadId -> e -> IO()
killThread :: ThreadId -> IO()
#+end_src
–ö–∏–¥–∞–µ—Ç ~AsyncException~ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –≤ –ø–æ—Ç–æ–∫

–ú–æ–∂–Ω–æ –ª–æ–≤–∏—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏—è. —Å–∏–≥–Ω–∞–ª—ã(SIGINT –∏ –ø—Ä.) - —Ç–æ–∂–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
#+begin_src haskell 
handle :: Exception e => IO a -> (e -> IO a) -> IO a
handle :: Exception e => (e -> IO a) -> IO a -> IO a
#+end_src


#+begin_src haskell
mask_ :: IO a -> IO a 
#+end_src
–ï—Å–ª–∏ –æ–±–µ—Ä–Ω—É—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –≤ ~mask_~ —Ç–æ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —É–±–∏—Ç–æ.


~bracket~, ~finally~ ‚Äî –∏–¥–∏–æ–º–∞ RAII

*~forkIO~ –ø–ª–æ—Ö–∞*
* –õ–µ–∫—Ü–∏—è 16
~STM~ –º–æ–Ω–∞–¥–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç –¥–µ–ª–∞—Ç—å –∞—Ç–æ–º–∞—Ä–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è —Å –∞–Ω–∞–ª–æ–≥–∞–º–∏ ~MVar~.

–†–∞—Å–ø–∞—Ä–∞–ª–ª–µ–ª–∏–≤–∞–Ω–∏–µ —á–∏—Ç—Å—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π. –ú–æ–Ω–∞–¥–∞ ~Eval~
#+begin_src haskell
runEval $ do
   a <- rpar (f x)
   b <- rpar (f y)
   return (a, b)
#+end_src

–†–∞–Ω—Ç–∞–π–º —Å–∞–º –ø–æ–∑–∞–±–æ—Ç–∏—Ç—å—Å—è –æ–± –æ–∂–∏–¥–∞–Ω–∏–∏ –ø–æ—Ç–æ–∫–æ–≤, –∫–æ–≥–¥–∞ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –ø–æ–ø—ã—Ç–∫–∞
–ø–æ–ª—É—á–∏—Ç—å –∑–∞–Ω–∏–µ ~a~ –∏–ª–∏ ~b~. ~rseq~ –ø–æ–∑–≤–æ–ª—è–µ—Ç —è–≤–Ω–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ?

#+begin_src haskell
runEval $ do
   a <- rpar (f x)
   b <- rseq (f y)
   return (a, b)
#+end_src
* –õ–µ–∫—Ü–∏—è 17
** –õ–∏–Ω–∑—ã
*–ü—Ä–æ–±–ª–µ–º–∞*: –°–µ—Ç—Ç–µ—Ä—ã –¥–ª—è record'–æ–≤ –±–æ–ª—å–Ω–æ

Lens(obj, field) ‚Äî –ø–∞—Ä–∞ –∏–∑ –≥–µ—Ç—Ç–µ—Ä–∞ –∏ —Å–µ—Ç—Ç–µ—Ä–∞
#+begin_src haskell
data Lens obj field = Lens
  { view :: obj -> field
  , set :: field -> obj -> obj
  }

view :: Lens obj field -> obj -> field
set  :: Lens obj field -> field -> obj -> obj

over :: Lens obj field :: (field -> field) -> (obj -> obj)
over lens updated obj = set lens (updater $ view lens obj) obj
#+end_src

–£–¥–æ–±–Ω–µ–µ —Å–ª–µ–¥—É—é—â–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
#+begin_src haskell
data Lens obj field = Lens
  { view :: obj -> field
  , over :: (field -> field) -> (obj -> obj) }
#+end_src

/–ü—Ä–∏–º–µ—Ä/:
#+begin_src haskell
data Person = Person
  { name :: String
  , age  :: Int
  , address :: Address
  }
data Address = Address
  { house :: Int
  , street :: Street
  , city :: City}

newtype City = City String
newtype Street = Street String

personAddressLens :: Lens Person Address
personAddressLens = Lens address (\fn obj -> obj { address = fn (address obj) })

addressCityLens :: Lens Address City
addressCityLens = Lens city (\fn obj -> obj { city = fn (city obj) })
#+end_src

–ü–æ–ø—Ä–æ–±—É–µ–º —Å–¥–µ–ª–∞—Ç—å –∫–æ–º–ø–æ–∑–∏—Ü–∏—é —ç—Ç–∏—Ö –ª–∏–Ω–∑
#+begin_src haskell
personCityLens :: Lens Person City
personCityLens =
  Lens (city . address)
  (\cityFn person -> person
     { address = address person
       { city = cityFn $ city $ address $ person }
     }
  )
#+end_src

–£–ø—Ä–æ—Å—Ç–∏–º
#+begin_src haskell
personCityLens :: Lens Person City
personCityLens =
  Lens (view addressCityLens . view personAddressLens)
       (over personAddressLens . over addressCityLens)
#+end_src

–°–¥–µ–ª–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏:
#+begin_src haskell
(.>)  :: Lens obj field
      -> Lens field subfield
      -> Lens obj subfield
o2f .> f2s = Lens (view f2s . view o2f)
                  (over o2f . over f2s)
#+end_src


–ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–¥–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –æ–±—ä–µ–¥–∏–Ω—è—é—â–∞—è ~view~ –∏ ~over~
#+begin_src haskell
type Lens s t a b = forall f. Functor f => (a -> f b) -> (s -> f t)
type Lens' s a = Lens s s a a
type Lens' s a = forall f. Functor f => (a -> f a) -> (s -> f s)

view :: S -> a
over :: (a -> a) -> (S -> S)
#+end_src

–î–æ–±–∞–≤–∏–º ~Identity~ –∫ ~over~
#+begin_src haskell
type LensOver s a = (a -> Identity a) -> (s -> Identity s)

over :: LensOver s a -> (a -> a) -> (s -> s)
over lens f x = runIdentity (lens (Identity . f) x)
#+end_src


–ü–æ–ø—Ä–æ–±—É–µ–º —Å–¥–µ–ª–∞—Ç—å ~view~
#+begin_src haskell
type LensGetter s a = (a -> Const a a) -> (s -> Const a s)

get :: LensGetter s a -> s -> a
get lens x = getConst (lens Const x)
#+end_src

#+begin_src haskell
lens :: (s -> a)  -> (s -> a -> s) -> Lens' s a
lens get set f s = set s <$> f (get s)
#+end_src

* –õ–µ–∫—Ü–∏—è 18
** Traverse
–ó–∞—á–µ–º –Ω—É–∂–Ω—ã –ª–∏–Ω–∑—ã —Å 4 —Ç–∏–ø–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
#+begin_src haskell
data Person a = Person
  { name :: String
  , age :: a
  ]}
#+end_src


~Traversal'~ –∫–æ–º–ø–∏–æ–∑–∏—Ä—É–µ—Ç—Å—è —Å ~Lens'~. –ó–∞–º–µ—Ç–∏–º —á—Ç–æ ~Traversal~ ‚Äî —á–∞—Å—Ç–Ω—ã–π —Å–ª—É—á–∞–π ~Lens~
#+begin_src haskell
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> (s -> f t)
type Traversal' obj field = forall f. Applicative f => (field -> f field) -> (obj -> f obj)

class (Functor t, Foldable t) => Traversable r where
  traverse :: Applicative f => (a -> f b) -> (t a) -> f (t b)

traversed :: Traversable t => Traversal' (t a) a
traversed = traverse

(.) :: Lens' a b -> Traversal' b c -> Traversal a c
#+end_src

–ú–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞–ø—Ä–∏–º–µ—Ä:
#+begin_src haskell
unit :: Lens' Game [Unit]
unit.traversed :: Traversal' Game Unit
unit.traversed.health :: Traversal' Game Int
#+end_src

–•–æ—Ç–∏–º –ø–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —Å—Ñ–æ–∫—É—Ä–∏—Å–æ–≤–∞–Ω—ã, –ø–æ–ª–æ–∂–∏—Ç—å –≤ —Å–ø–∏—Å–æ–∫
#+begin_src haskell
data Endo = Endo { appEndo :: a -> a}

type Getting r s a = (a -> Const r a) -> s -> Const r s

toListOf :: Getting (Endo [a]) s a -> s -> [a]
(^..) :: s -> Getting (Endo [a]) s a -> [a]

game^..unit.traversed.health :: Lens' Game [Int] -- ???
#+end_src


~zoom~:
#+begin_src haskell
partyLoc :: Traversal' Game Point
partyLoc = unit.travesred.position

retreat :: StateT Game IO ()
retreat = do
  lift $ putStrLn "Retreat!"
  zoom partyLoc $ do
    x += 10
    y += 10

battle :: StateT Game IO ()
battle = do
  --snip--
  zoom (boss.position) $ do
    x += 10
    y += 10

#+end_src

** –ü—Ä–∏–∑–º—ã

#+begin_src haskell
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)

preview :: Prism' s a -> s -> Maybe a
review :: Prism' s a -> a -> s
#+end_src

–ü—Ä–∏–º–µ—Ä –¥–ª—è ~Either~ –∏ ~Maybe~
#+begin_src haskell
_Left :: Prism' (Either a b) a
_Just :: Prism' (Maybe a) a
#+end_src
#+begin_src 
ghci> preview _Left (Left "hi")
Just "ho"
ghci> preview _Left (Right "hi")
Nothing
#+end_src
#+begin_src 
ghci> review _Left "hi"
Left "hi"
#+end_src

–ë–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–π –ø—Ä–∏–º–µ—Ä:
#+begin_src haskell
data X = mkX { _fieldX :: String }
data C = MkC1 X | MkC2 Y
data B = MkB { _fieldB :: C }
data A = MkA { _fieldA :: [B] }

foo :: A
#+end_src
–ö–∞–∫ –∏–∑–º–µ–Ω–∏—Ç—å ~fieldX~ –≤ ~A~, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –≤ ~X~
#+begin_src haskell
foo & fieldA.traversed.fieldB._MkC1.fieldX .~ "New string" 
#+end_src
* –õ–µ–∫—Ü–∏—è 19
–ú–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –°–∏—à–Ω—ã–π –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä

–ú–æ–∂–µ–º –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ª–∏–Ω–∑—ã –Ω–∞–ø–∏—Å–∞–≤ –ø—Ä–æ—Å—Ç–æ ~makeLenses ''Game~

–ù–∞–ø–∏—à–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–µ—Ä–≤–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ —Ç—é–ø–ª–æ–≤ —Ä–∞–∑–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞:
#+begin_src haskell
VarP :: Name -> Pat
VarE :: Name -> Exp

newName :: String -> Q Name
varE :: Name -> Q Expr
varP :: Name -> Q Pat
#+end_src

–ö–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∫–æ–¥ ~\(x, _, _) -> x~ –≤ AST 
#+begin_src haskell
LamE [TupP [VarP x_1, WildP, WildP]] (VarE x_1)
#+end_src

#+begin_src haskell
fst3 = do
  x <- newName "x"
  lamE [tupP [varP x, wildP, wildP]] (varE x) -- \(x, _, _) -> x
#+end_src

#+begin_src haskell
fst3 :: Q Expr
$(fst3) :: (t2, t1, t) -> t2
#+end_src
#+begin_src haskell
ghci> $(fst3) (1, 2, 3)
1
#+end_src

#+begin_src haskell
fstN = do
  x <- newName "x"
  lamE [tupP $ varP x : replicate (n - 1) wildP] (varE x) -- \(x, _, _, ... , _) -> x
#+end_src

*NB*: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏ —Å–∞–º–∏ –º–∞–∫—Ä–æ—Å—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ —Ä–∞–∑–Ω—ã—Ö –º–æ–¥—É–ª—è—Ö

~-XQuasiQuotes~:
–¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å AST –Ω–µ —Ä—É—á–∫–∞–º–∏ –∞ –≤ ~[|...|]~
#+begin_src haskell
ghci> runQ [| \x -> x |]
LamE [VarP x_0] (VarE x_0)
#+end_src

–ß—Ç–æ–±—ã —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥—Ä—É–≥–∏–µ —à—Ç—É–∫–∏, —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ —ç—Ç–æ –±–æ–∑–Ω–∞—á–∞–µ–º:
- –û–±—ä—è–≤–ª–µ–Ω–∏–µ: ~[d|..|]~
- –í—ã—Ä–∞–∂–µ–Ω–∏–µ: ~[e|..|]~
- –¢–∏–ø: ~[t|..|]~
- –ü–∞—Ç—Ç–µ—Ä–Ω: ~[p|..|]~
- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ –º–æ–≥—É—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å —Å–≤–æ–∏ —Ñ–æ—Ä–º–∞—Ç—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω—ã–π —Ç–µ–∫—Å—Ç

** DSL–∫–∏
–ü–æ–ø—Ä–æ–±—É–µ–º —Å–¥–µ–ª–∞—Ç—å DSL –¥–ª—è –∞—Ä–∏—Ñ–º–µ—Ç–∏—á—Å–∫–∏—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π
#+begin_src haskell
data ArithExpr = AENum Int
               | AEPlus ArithExpr ArithExpr
               | AEAnd ArithExpr ArithExpr
               | AEGt ArithExpr ArithExpr
#+end_src
*–ü—Ä–æ–±–ª–µ–º–∞*: –º–æ–∂–µ–º —Å–∫–ª–∞–¥—ã–≤–∞—Ç—å –±—É–ª—ã

~-XGADTs~:
#+begin_src haskell
data ArithExpr a where
  AENum :: Int -> ArithExpr Int
  AEPlus :: ArithExpr Int -> ArithExpr Int -> ArithExpr Int
  AEAnd :: ArithExpr Bool -> ArithExpr Bool -> ArithExpr Bool
  AEGt :: ArithExpr Int -> ArithExpr Int -> ArithExpr Bool
#+end_src
–¢–µ–ø–µ—Ä—å –Ω–µ –º–æ–∂–µ–º –Ω–∞–ø–∏—Å–∞—Ç—å –Ω–µ–∫–æ—Ä–µ–∫—Ç–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ

–í —Ç–æ–∂–µ –≤—Ä–µ–º—è, –µ—Å–ª–∏ –ø–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–ø–∏—Å–∞—Ç—å –ø–∞—Ä—Å–µ—Ä –¥–ª—è —Ç–∞–∫–∏—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π, —Ç–æ
–ø—Ä–æ—Å—Ç–æ –Ω–µ —Å–º–æ–∂–µ–º —ç—Ç–æ–≥–æ —Å–¥–µ–ª–∞—Ç—å. –°–ª–µ–¥—É—é—â–∏–π –∫–æ–¥ –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:
#+begin_src haskell
parse :: String -> Maybe (ArithExpr a)
parse "1" = Just (AENum 1)
parse _ = Nothing
#+end_src

–ò—Å–ø–æ–ª—å–∑—É–µ–º —ç–∫–∑–∏—Å—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ —Ç–∏–ø—ã:
#+begin_src haskell
data SomeAE where
  SomeAE :: Show a => ArithExpr a -> SomeAE

interpret :: ArithExpr a -> a
  
parse :: String -> Maybe SomeAE
parse "1" = Just (SomeAE $ AENum 1)
parse "1+2" = Just $ SomeAE $ AENum 1 `AEPlus` AENum 2
parse _ = Nothing

interpretShow :: SomeAE -> String
interpretShow (SomeAE expr) = show (interpret expr)
#+end_src


–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º ~-XExistentialQuantification~
#+begin_src 
data SomeAE = forall a. Show a => SomeAE (ArithExpr a)  
#+end_src

–•–æ—Ç–∏–º –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–ª—É—á–∏—Ç—å ~Int~ –∏–∑ ~interpret~. –ú–æ–∂–µ–º –ø–æ–ª—É—á–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–∏–ø–µ –≤ —Ä–∞–Ω—Ç–∞–π–º–µ
#+begin_src haskell
data SomeAE where
  SomeAE :: (Typeable a, Show a) => ArithExpr a -> SomeAE

class Typeable (a :: k)

data a :~: b where
  Refl :: a :~: a

eqT :: forall a b. (Typeable a, Typeable b) => Maybe (a :~: b)
#+end_src

#+begin_src haskell
parseInt :: String -> Maybe (ArithExpr Int)
parseInt s = parse s >>=
  \(SomeAE (expr :: ArithExpr t)) ->
    do
      Refl <- eqT @t @Int
      pure expr
#+end_src
* –õ–µ–∫—Ü–∏—è 20
** –ì–¥–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º ~forall~
- ~-XRankNTypes~
  #+begin_src haskell
applyToTuple :: (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int)
applyToTuple f (x, y) = (f x, f y)
  #+end_src

- –í—Å–ø–æ–º–Ω–∏–º ST:
  #+begin_src haskell
runSt :: forall a. (forall s. ST s a)  -> a

newSTRef :: forall a s. a -> ST s (STRef s a)
readSTRef :: forall a s. STRef s a -> ST s a
writeSTRef :: forall a s. STRef s a -> a -> ST s ()
  #+end_src
  
  –ù–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ST –º–æ–Ω–∞–¥—É –Ω–µ–º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏. –ù–µ –º–æ–∂–µ–º —Ö–∞–∫–Ω—É—Ç—å ST –º–æ–Ω–∞–¥—É
  #+begin_src haskell
changeVarWrong var =
  let _ = runST $ writeSTRef var 10
      _ = runST $ writeSTRef var 42
  in var
  #+end_src
  –ù–µ –º–æ–∂–µ–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Ç–∏–ø, —Ç.–∫. —Ç–∏–ø ~s~ –≤–Ω—É—Ç—Ä–∏. –¢–æ –µ—Å—Ç—å —Ç–∏–ø ~s~ ‚Äî –º–∞—Ä–∫–µ—Ä
  –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞, —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –¥–ª—è –Ω–µ–≥–æ
- –í –¥–∞—Ç–∞—Ç–∏–ø–∞—Ö
  #+begin_src haskell
data Ctx = Ctx { modulus :: Int }

newtype Action a = Action
  { runAction :: forall m. (MonadReader Ctx m, MonadCatch m) => m a }
  #+end_src
  –≠—Ç–æ –Ω–µ —ç–∫–∑–∏—Å—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —Ç–∏–ø!
- ~-XScopedTypeVariables~
** Final tagless DSLs
–í–º–µ—Å—Ç–æ –≤—ã—à–µ–æ–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –¥–∞—Ç–∞—Ç–∞–π–ø–∞ ~ArithExpr~:
#+begin_src haskell
class ArithExpr expr where
  aeNum :: Int -> expr Int
  aePlus :: expr Int -> expr Int -> expr Int
  aeAnd :: expr Bool -> expr Bool -> expr Bool
  aeGt :: expr Int -> expr Int -> expr Bool
#+end_src
#+begin_src haskell
newtype ToS a = ToS { toString :: String }
  deriving (Show, Semigroup)

castTS :: ToS a -> ToS b
castTS (ToS s) = ToS s

instance ArithExpr ToS where
  aeNum = ToS . show
  aePlus a b = a <> (ToS " + ") <> b
  aeAnd a b = a <> (ToS " && ") <> b
  aeGt a b = castTS a <> (ToS " > ") <> castTS b
#+end_src

* –õ–µ–∫—Ü–∏—è 21
–ü—Ä–æ –∫–∞–π–Ω–¥—ã
#+begin_src haskell
newtype ReaderT r (m :: * -> *) (a :: *) = ReaderT { runReaderT :: r -> m a }
ReaderT :: * -> (* -> *) -> * -> *
#+end_src

#+begin_src haskell
class Num a where
  --snip--

Num :: * -> Constraint
#+end_src

–ú–æ–∂–µ–º –¥–µ–ª–∞—Ç—å –∞–ª–∏–∞—Å—ã –¥–ª—è –∫–æ–Ω—Å—Ç—Ä–µ–π–Ω—Ç–æ–≤
#+begin_src haskell
type MyConstraint a = (Reade a, Num a, Show a)

foo :: MyConstraint a => String -> a -> a
#+end_src

#+begin_src haskell
type ConstraintEndomorphism p a = p a => a -> a
ConstraintEndomorphism :: (* -> Constraint) -> * -> *
#+end_src

~-XTypeOperators~
#+begin_src haskell
data a * b = Mult a b
(*) :: Num a => a -> a -> a -- type
(*) :: * -> * -> * -- kind
#+end_src

** –ö–∞—Å—Ç–æ–º–Ω—ã–π –∫–∞–π–Ω–¥—ã
#+begin_src haskell
data Z
data S n

data Vec :: * -> * -> * where
  Nil :: Vec a Z
  Cons :: a -> Vec a n -> Vec a (S n)


v2 :: Vec Int (S (S Z))
v2 = 1 `Cons` (2 `Cons` Nil) -- ok

v3 :: Vec Int Char -- –Ω–µ —Ö–æ—Ç–∏–º —á—Ç–æ–±—ã —ç—Ç–æ –±—ã–ª–æ –≤–∞–ª–∏–¥–Ω–æ
-- v3 = ??
#+end_src

–ï—Å–ª–∏ –≤–∫–ª—é—á–∏—Ç—å ~-XDataKinds~, –¥–ª—è –∫–∞–∂–¥–æ–π ~data~ —Å–æ–∑–¥–∞–µ—Ç—Å—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –∫–∞–π–Ω–¥
#+begin_src haskell
data Nat = Z | S Nat

data Vec :: * -> Nat -> * where
  Nil :: Vec a Z
  Const :: a -> Vec a n -> Vec a (S n)
#+end_src

#+begin_src haskell
data Nat = Zero | Succ Nat

Succ :: Nat -> Nat -- type
Nat :: * -- kind
#+end_src
–° —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º
#+begin_src haskell
Succ :: Nat -> Nat -- kind

type Two = 'Succ ('Succ 'Zero)
Two :: Nat -- kind
#+end_src

–° –∞–ø–æ—Å—Ç—Ä–æ—Ñ–∞–º–∏ —Ç–∏–ø—ã. –±–µ–∑ ‚Äî —Ç–∏–ø–æ–≤–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä

–ü—Ä–∏–º–µ—Ä –¥–ª—è –ª–∏—Å—Ç–æ–≤, ~-XTypeOperators~
#+begin_src haskell
Prelude> :set -XDataKinds
Prelude> :k '[]
'[] :: [a]
Prelude> :k '[Int, Bool]
'[Int, Bool] :: [*]
Prelude> :k '[Maybe, Either String]
'[Maybe, Either String] :: [* -> *]
Prelude> :set -XTypeOperators
Prelude> :k (Int ': '[Bool])
(Int ': '[Bool]) :: [*]
#+end_src

–° —Ç–∞–∫–∏–º–∏ —Å—Ç—Ä–æ–≥–∏–º–∏ —Å–ø–∏—Å–∫–∞–º–∏, –º–æ–∂–µ–º —Å–¥–µ–ª–∞—Ç—å ~zip~ —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–ø–∏—Å–∫–æ–≤ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω–Ω—ã


–ì–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏:
#+begin_src haskell
data HList :: [*] -> * where
  HNil :: HList '[]
  (:^) :: a -> HList t -> HList (a ': t)

infixr 2 :^

foo0 :: HList '[]
foo0 = HNil

foo1 :: HList '[Int]
foo1 = 3 :^ HNil

foo2 :: HList '[Int, Bool]'
foo2 = 5 :^ False :^ HNil
#+end_src

~Show~ –¥–ª—è —ç—Ç–æ–π —Ñ–∏–≥–Ω–∏
#+begin_src haskell
instance Show (HList '[]) where
  show _ = "H[]"

instance (Show e, Show (HList l)) => Show (HList (e ': l)) where
  show (x :^ l) = let 'H' : '[' : s = show l
                  in "H[" ++ show x ++ (if s == "]" then s else ", " ++ s)
#+end_src

–ß–∏—Å–ª–∞ –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ç–∏–ø–æ–≤:
#+begin_src haskell
data Vec :: * -> Nat -> * where
  Nil :: Vec a 0
  (:>) :: a -> Vec a n -> Vec a (n + 1)
#+end_src
#+begin_src haskell
newtype ArrPtr (n :: Nat) a = ArrPtr (Ptr a)

clearPage :: ArrPtr 4096 Word8 -> IO ()
#+end_src
* –õ–µ–∫—Ü–∏—è 22
–ö–∞–∫ —Å–¥–µ–ª–∞—Ç—å ~+~?
#+begin_src haskell
newtype Foo bar = MkFoo { unFoo :: bar }

MkFoo :: bar -> Foo bar -- (term level)
Foo :: * -> * -- (type level)

data Foo a where
  Foo :: Int -> Foo Int
  Bar :: Char -> Foo Double

Foo :: Int -> Foo Int -- (term level)
Bar :: Char -> Foo Double -- (term level)
Foo :: * -> * -- (type level)
#+end_src
–•–æ—Ç–∏–º –ø–∏—Å–∞—Ç—å —á—Ç–æ-—Ç–æ –≤—Ä–æ–¥–µ
#+begin_src haskell
type fun Foo a where
  | a == Char = Double
  | otherwise = a
#+end_src

** Type and data families
#+begin_src haskell
-- –æ—Ç–∫—Ä—ã—Ç–∞—è type family
type family Foo var :: * where
  Foo Char = Double
  Foo b = b

-- –∑–∞–∫—Ä—ã—Ç–∞—è type family
type family Foo bar :: *
type instance Foo Char = Double
type instance Foo Int = Int

-- —Ç–∞–∫ –Ω–µ–ª—å–∑—è! (–º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –≤ –æ—Ç–∫—Ä—ã—Ç—ã—Ö)
type family Foo bar :: *
type instance Foo Char = Double
type instance Foo a = a
#+end_src

#+begin_src haskell
data family Foo bar :: *
data instance Foo Int = MkFoo Int
#+end_src


#+begin_src haskell
class Foo p where
  type AType p :: *
  data BType p :: *

  make :: AType p -> BType p

instance Foo Int where
  type AType Int = Int
  data BType Int = B Integer

  make = B .toInteger

type family FromMaybe (m :: Maybe *) (def :: *) :: * where
  FromMaybe ('Just t) def = t
  FromMaybe 'Nothing def = def
#+end_src
~FromMaybe ('Just Int) Bool ~ Int~

#+begin_src haskell
type family Foo bar :: * where
  Foo Char = Double
  Foo a = a

show' :: Show (Foo a) => Foo a -> String
show' = show
#+end_src
–í –∫—Ä–∞—Ç—Ü–µ: –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –Ω—É–∂–Ω–∞ –∏–Ω—ä–µ—Ç–∫–∏–≤–Ω–æ—Å—Ç—å —Ç–∏–ø–∞ ~a~ –≤ ~show'~. –≠—Ç–æ
—Ä–µ—à–∞–µ—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–º:
#+begin_src haskell
{-# LANGUAGE TypeFamilyDependencies #-}

type family Foo a = r | r -> a where
  Foo Char = Double
  Foo Int = Int
#+end_src
–ß–µ—Ä–µ–∑ ~r -> a~ –æ–±–µ—â–∞–µ–º –∏–Ω—ä–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å. –ü—Ä–∏—à–ª–æ—Å—å —É–±—Ä–∞—Ç—å –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã–π
–ø–∞—Ç—Ç–µ—Ä–Ω, —Ç.–∫. –æ–Ω –Ω–∞—Ä—É—à–∞–µ—Ç –∏–Ω—ä–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å. –¢–µ–ø–µ—Ä—å ~show'~ —Ä–∞–±–æ—Ç–∞–µ—Ç

** ~Free~ Monad
#+begin_src haskell
data Free f a = Pure a | Free (f (Free f a))

instance Functor f => Monad (Free f) where
  return = pure

  Pure a >>= f = f a
  Free m >>= f = Free ((>>= f) <$> m)
#+end_src

* DRIFTED –õ–µ–∫—Ü–∏—è 23
#+begin_src haskell
class Functor w => Comonad w where
  extract :: w a -> a
  duplicate :: w a -> w (w a)
  extend :: (w a -> b) -> w a -> w b

(=>>) :: Comonad w => w a -> (w a -> b) -> w b
#+end_src

–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
#+begin_src haskell
duplicate w = extend id w
extend f w = fmap f (duplicate w)
#+end_src


–ü—Ä–æ—Å—Ç–æ–π –ø—Ä–∏–º–µ—Ä:
#+begin_src haskell
data Identity a = Identity { runIdentity :: a } 

instance Comonad Indetity where
  extract = runIdentity
  duplicate = Identity
#+end_src

~Maybe~, ~[]~ –Ω–µ –∫–æ–º–æ–Ω–∞–¥—ã(–Ω–µ–ª—å–∑—è —Å–¥–µ–ª–∞—Ç—å ~extract~), –∞ ~NonEmpty~ –≤–ø–æ–ª–Ω–µ —Å–µ–±–µ.

–î–≤–æ–π—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –≤ –º–æ–Ω–∞–¥–µ:
#+begin_src haskell
return  :: a -> m a
extract :: a <- m a


(>>=) :: m a -> (a -> m b) -> m b
(=>>) :: m a <- (a <- m b) <- m b


join     :: m (m a) -> m a
dupicate :: m (m a) <- m a
#+end_src

*–ù–µ–∑–∞–∫–æ–Ω—á–µ–Ω–æ*
