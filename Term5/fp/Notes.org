#+PUBNOTE:html
#+SETUPFILE: ../../level-subj.org
#+title: –ó–∞–º–µ—Ç–∫–∏ –∫ —ç–∫–∑–∞–º–µ–Ω—É

* –õ–µ–∫—Ü–∏—è 7
#+begin_src haskell
class Applicative m => Monad m where
  return :: a -> m a                -- return
  (>>=) :: m a -> (a -> m b) -> m b -- bind
#+end_src

–î–ª—è ~Maybe~:
#+begin_src haskell
instance Monad Maybe where
  return = Just

  Nothing >>= _ = Nothing
  Just a >>= f = f a
#+end_src


–ü—Ä–∏–º–µ—Ä –¥–ª—è ~Identity~
#+begin_src haskell
newtype Identity a = Identity { runIdentity :: a } 
#+end_src
–ò–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã —Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã–π


–ü—Ä–∏–º–µ—Ä –¥–ª—è ~Either~
#+begin_src haskell
instance Monad (Either e)  where
  --snip--
#+end_src
*NB*: –ó–¥–µ—Å—å —Ç–∏–ø ~e~ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω—ã–π –¥–ª—è –æ–¥–Ω–æ–≥–æ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–æ–≥–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è

–ö–æ–º–ø–æ–∑–∏—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –º–æ–Ω–∞–¥:
#+begin_src haskell
(<=<)  :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
(>=>)  :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
#+end_src

- ~m >>= (f >=> g) ‚â° m >>= f >>= g~
- ~m >>= (f <=< g) ‚â° m >>= g >>= f~
- –ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å

–ü—Ä–∏–º–µ—Ä –º–æ–Ω–∞–¥—ã ~[]~
#+begin_src haskell
instance Monad [] where
  return x = [x]

  l >>= f = concat (map f l)
#+end_src


#+begin_src haskell
(>>)  :: Monad m => m a -> m b -> mb
m >> k = m >>= \_ -> k
#+end_src

–ü—Ä–∏–º–µ—Ä
#+begin_src haskell
ghci> [True, False]  >> [1, 2, 3]
[1, 2, 3, 1, 2, 3]
#+end_src



~guard~ –¥–ª—è —Å–ø–∏—Å–∫–∞
#+begin_src haskell
guard :: Bool -> [()]
guard True  = [()]
guard False = []
#+end_src

–ü–æ–ª–∏–º–æ—Ä—Ñ–Ω–∞—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞
#+begin_src 
guard :: (Alternative f) => Bool -> f ()
#+end_src

–ë–µ—Å–ø–æ–ª–µ–∑–Ω—ã–π –ø—Ä–∏–º–µ—Ä
#+begin_src haskell
ghci> [True, False, True]  >> [1, 2]
[1, 2, 1, 2, 1, 2]
ghci> [True, False, True] >>= \b -> guard b >> [1, 2]
[1, 2, 1, 2]
#+end_src


#+begin_src 
join :: Monad m => m (m a) -> m a
#+end_src

–ù–µ–ª—å–∑—è –Ω–∞–ø–∏—Å–∞—Ç—å –≤–∞–ª–∏–¥–Ω—ã–π –∏–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã üò≠
#+begin_src haskell
data BarBaz a = Bar a | Baz a a 
#+end_src


#+begin_src haskell
liftM :: Monad m => (a -> b) -> m a -> m b
#+end_src

–ê–ª—å—Ç–µ—Ä–Ω–∏—Ç–≤–Ω—ã–µ –±—É–ª–µ–≤—Å–∫–∏–µ –æ–ø—Ä–µ—Ä–∞—Ç–æ—Ä—ã
#+begin_src haskell
(||^), (&&^) :: m Bool -> m Bool -> m Bool
#+end_src


–ó–∞–∫–æ–Ω—ã –º–æ–Ω–∞–¥
1. ~return a >>= f  ‚â° f a~
1. ~m >>= return    ‚â° m~
1. ~(m >>= f) >>= g ‚â° m >>= (\x -> f x >>= g)~

–ú–æ–∂–µ–º –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –¥–æ–∫–∞–∑–∞—Ç—å –∑–∞–∫–æ–Ω—ã —Ä—É–∫–∞–º–∏
* –õ–µ–∫—Ü–∏—è 8
** Writer
#+begin_src haskell
newtype Wrtier w a = Writer { runWriter :: (a, w) }  -- a is value, w is log

instance Monoid w => Moand (Writer w) where
  return a = Writer (a, mempty)

  Writer (a, oldLog) >>= f = let Wrtier (b, newLog) = f a
                             in Writer (b, oldLog <> newLog)
#+end_src


–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src haskell
tell       :: w -> Writer w ()
execWriter :: Writer w a -> w
writer     :: (a, w) -> Writer w a
#+end_src

- –ï—Å—Ç—å –∏–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã –¥–ª—è –ø–∞—Ä—ã, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ ~Writer~
- ~Writer~ –Ω–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π, –∫—É—à–∞–µ—Ç –º–Ω–æ–≥–æ –ø–∞–º—è—Ç–∏

** Reader

#+begin_src haskell
newtype Reader e a = Reader { runReader :: e -> a } -- e is environment

instance Monad (Reader e) where
  return a = Reader $ \_ -> a

  m >>= f = Reader $ \r -> runReader (f $ runReader m r) r
#+end_src

–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src haskell
ask   :: Reader e e
asks  :: (e -> a) -> Reader e a
local :: (e -> b) -> Reader b a -> Reader e a
#+end_src


*Note*: Typed holes ‚Äî ~foo x = _x~

** State

#+begin_src haskell
newtype State s a = State { runState :: s -> (a, s) } 

instance Monad (State s) where
  return a = State $ \s -> (a, s)

  oldState >>= f = State $ \s -> let (a, newState) = runState oldState s
                                 in runState (f a) newState
#+end_src


–ü—Ä–∏–º–µ—Ä –¥–ª—è —Å—Ç–µ–∫–∞
#+begin_src haskell
type Stack = [Int]

pop :: State Stack Int
pop = State $ \(x:xs) -> (x, xs)

push :: Int -> State Stack ()
push x = State $ \xs -> ((), x:xs)
#+end_src

–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src haskell
get       :: State s s
put       :: s -> State s ()
modify    :: (s -> s) -> State s ()
gets      :: (s -> a) -> State s a
withState :: (s -> s) -> State s a -> State s a
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
#+end_src



–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –º–æ–Ω–∞–¥–æ–≤
#+begin_src haskell
replicateM :: Moad m => Int -> m a -> m [a] 

forM_ :: (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
#+end_src

** Cont
#+begin_src haskell
addCPS :: Int -> Int -> ((Int -> r) -> r)
addCPS x y = \k -> k (x + y)
#+end_src

#+begin_src haskell
newtype Cont r a = Cont { runCont :: (a -> r) -> r } 
#+end_src

* –õ–µ–∫—Ü–∏—è 9

–ü–æ—á–µ–º—É –Ω–µ –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç –≤–≤–æ–¥ —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–π
#+begin_src haskell
getChar :: Char 
get2Char :: [Char]
get4Char :: [Char]
#+end_src

–ò—Å–æ–ø–ª—å–∑—É–µ–º —á—Ç–æ-—Ç–æ –≤—Ä–æ–¥–µ
#+begin_src haskell
getChar :: RealWorld -> (Char, RealWorld) 
get2Char :: ReadWorld -> ([Char], RealWorld)
get4Char :: ReadWorld -> ([Char], RealWorld)
#+end_src


~do~ –Ω–æ—Ç–∞—Ü–∏—è

–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
#+begin_src 
sequence_ :: [IO a] -> IO ()
#+end_src

~return~ –Ω–µ —Ç–æ —á–µ–º –∫–∞–∂–µ—Ç—Å—è

–õ–µ–Ω–∏–≤–æ—Å—Ç—å —Å —Ñ–∞–π–ª–∞–º–∏

FFI, ~IORef~, ~IOArray~, ~IOException~, ~unsafePerformIO~

~OverloadedStrings~

~Text~, ~ByteString~ –∏—Å–ø–æ–ª—å–∑—É—é—Ç ~unsafe~ –æ–ø–µ—Ä–∞—Ü–∏–∏, –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –±–µ–∑–æ–ø–∞—Å–Ω–æ

* –õ–µ–∫—Ü–∏—è 10
#+begin_src haskell
newtype Parser a = Parser { runP :: String -> Maybe (a, String) } 
#+end_src


–î–µ–ª–∞–µ–º –ø—Ä–æ—Å—Ç—ã–µ –ø–∞—Ä—Å–µ—Ä—ã, –∫–æ–º–±–∏–Ω–∏—Ä—É—è –∏—Ö –ø–æ–ª—É—á–∞–µ–º –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ

#+begin_src haskell
ok :: Parser ()
ok = Parser $ \s -> Just ((), s)

isnot :: Parser a -> Parser ()
isnot parser = Parser $ \s ->
  case runP parser s of
    Just _  -> Nothing
    Nothing -> Just ((), s)

eof :: Parser ()
eof = Parser $ \s ->
  case s of
    [] -> Just ((), "")
    _  -> Nothing


satisfy :: (Char -> Bool) -> Parser Char
satisfy p = Parser $ \s ->
  case s of
    [] -> Nothing
    (x:xs) -> if p x then Just (x, xs) else Nothing

notok :: Parser ()
notok = isnot ok

char :: Char -> Parser Hcar
char c = satisfy (== c)

--snip--

instance Functor Parser where
  fmap f (Parser parser) = Parser (fmap (first f) . parser)

insatnce Applicative Parser where
  pure a = Parser $ \s -> Just (s, s)

  Parser pf <*> Parser pa = Praser $ \s ->
    case pf s of
      Nothing -> Nothing
      Just (f, t) -> case pa t of
        Nothing -> Nothing
        Just (a, r) -> Just (f a, r)


instance Monad Parser where
  return = pure

  p >>= f = Parser $ \s ->
    case runP p s of
      Nothing -> Nothing
      Just (a, t) -> runP (f a) t

instance Aternative Parser
  --snip--
#+end_src

* –õ–µ–∫—Ü–∏—è 11
*** Unit testing ‚Äî ~HSpec~
–ú–æ–∂–µ—Ç —Å–∞–º –∏—Å–∫–∞—Ç—å —Ç–µ—Å—Ç—ã –≤ –º–æ–¥—É–ª—è—Ö —Å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º ~spec~?

- ~shouldSatisfy~ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ –ø—Ä–µ–¥–∏–∫–∞—Ç—É
- ~shouldBe~ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ

#+begin_src haskell
hspecTestTree :: IO TestTree
hspecTestTree = testSpec "Simple parser" spec_Parser

spec_Parser :: Spec
spec_Parser = do
  describe "eof works" $ do
    it "eof no empty input" $
      runP eof "" `shouldSatisfy` isJust
    it "eof no non-empty input" $
      runP eof "x" `shouldSatisfy` isNothing
  describe "char works" $ do
    it "char parses character" $
      runP (char 'a') "abc" `shouldBe` Just ('x', "bc")
#+end_src

*** Property-based ‚Äî ~Hedgehog~
/–ü—Ä–∏–º–µ—Ä/: ~‚àÄ xs. reverse (reverse xs) ‚â° xs~

#+begin_src haskell
genIntList :: Gen [Int]
genIntList =
  let listLength = Range.linear 0 10000
  in Gen.List listLength Gen.enumBounded

prop_reverse :: Property
prop_reverse = property $
  forAll genIntList >>= \xs ->
  List.reverse (List.reverse xs) === xs
#+end_src

Shrinking ‚Äî —É–º–µ–Ω—å—à–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ —Ç–µ—Å—Ç–∞ –¥–æ —á–∏—Ç–∞–±–µ–ª—å–Ω–æ–≥–æ –≤–∏–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–≤—Ç–æ—Ä—è–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ

–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—Ä–∞—Ç–Ω—ã—Ö
#+begin_src 
read        . show      ‚â° id
decode      . encode    ‚â° id
deserialize . serialize ‚â° id
#+end_src

–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫–æ–Ω–æ–≤ –º–æ–Ω–æ–∏–¥–æ–≤ –∏ –ø—Ä..
#+begin_src 
(a <> b) <> c ‚â° a <> (b <> c)
a <> mempty   ‚â° a
mempty <> a   ‚â° a
#+end_src

* –õ–µ–∫—Ü–∏—è 12
–ú–æ–∂–µ–º –∫–æ–º–ø–æ–∑–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ç–æ—Ä—ã, –∞–ø–ø–ª–∏–∫–∞—Ç–∏–≤—ã, –∏ —Ç.–¥.
#+begin_src haskell
newtype Compose f g a = Compose { getCompose :: f (g a) }

instance (Functor f, Functor g) => Functor (Compose f g)
instance (Foldable f, Foldable g) => Foldable (Compose f g)
instance (Applicative f, Applicative g) => Applicative (Compose f g)
--snip--
#+end_src
*–ù–æ –Ω–µ –º–æ–Ω–∞–¥*

–î–ª—è ~Maybe~
#+begin_src haskell
newtype MaybeIO = MaybeIO { runMaybeIO :: IO (Maybe a) }

instance Monad MaybeIO where
  return x = MaybeIO (return (Just x))
  MaybeIO action >>= f = MaybeIO $ do
    result <- action
    case result of
      Nothing -> return Nothing
      Just x -> runMaybeIO (f x)
#+end_src

–ü—Ä–æ–±–ª–µ–º–∞
#+begin_src haskell
result <- runMaybeIO $ do
  c1 <- MaybeIO $ tryConnect "host1"
  print "Hello"
  c2 <- MaybeIO $ tryConnect "host2"
#+end_src

~print~ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ ~Maybe~

#+begin_src haskell
transformIO2MaybeIO :: IO a -> MaybeIO a
transformIO2MaybeIO action = MaybeIO $ do
  result <- action
  return (Just result)
#+end_src

–ü–µ—Ä–≤—ã–π —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä
#+begin_src haskell
newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } 

type MaybeIO = MaybeT IO

instance Monad m => Monad (MaybeT m) where
  return x = MaybeT (return (Just x))
  MaybeT action >>= f = MaybeT $ do
    result <- action
    case result of
      Nothing -> return Nothing
      Just x -> runMaybeT (f x)

transformIO2MaybeT :: Functor m => m a -> MaybeT m a
transformIO2MaybeT action = MaybeT . fmap Just
#+end_src


–ö–ª–∞—Å—Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–æ–≤
#+begin_src haskell
class MonadTrans t where
  lift :: Monad m => m a -> t m a
#+end_src
- ~lift . return ‚â° return~
- ~lift (m >>= f) ‚â° lift m >>= (lift . f)~


–ü—Ä–∏–º–µ—Ä –¥–ª—è ~Reader~
#+begin_src haskell
newtype ReaderT r m a = Reader T { runReaderT :: r -> m a }

type Reader r a = ReaderT r Identity a
type LoggerIO a = ReaderT LoggerName IO a
#+end_src

–∏–Ω—Å—Ç–∞–Ω—Å –º–æ–Ω–∞–¥—ã –¥–ª—è ~ReaderT~ –ø–æ—á—Ç–∏ —Ç–∞–∫–æ–π –∂–µ –∫–∞–∫ –∏ –¥–ª—è ~Reader~

*NB* –¢–∞–±–ª–∏—Ü–∞ —Ç—Ä–∞–Ω—Å–æ—Ñ—Ä–º–µ—Ä–æ–≤
| *Base Monad* | *Transormer* | *Original Type*   | *Combined Type*       |
|------------+------------+-----------------+---------------------|
| ~Maybe~    | ~MaybeT~   | ~Maybe a~       | ~m (Maybe a)~       |
| ~Either~   | ~EitherT~  | ~Either a b~    | ~m (Either a b)~    |
| ~Writer~   | ~WriterT~  | ~(a, w)~        | ~m (a, w)~          |
| ~Reader~   | ~ReaderT~  | ~r -> a~        | ~r -> m a~          |
| ~State~    | ~StateT~   | ~s -> (a, s)~   | ~s -> m (a, s)~     |
| ~Cont~     | ~ContT~    | ~(a -> r) -> r~ | ~(a -> m r) -> m r~ |

~IO~ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–æ–º


*–ü—Ä–æ–±–ª–µ–º–∞*: –ï—Å–ª–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–æ–≤ –º–Ω–æ–≥–æ, —Ç–æ –ø—Ä–∏–¥–µ—Ç—Å—è –ø–∏—Å–∞—Ç—å –º–Ω–æ–≥–æ ~lift~

–í—Å–µ –≤—ã—à–µ –≤ –ø–∞–∫–µ—Ç–µ ~transformers~. –ü–∞–∫–µ—Ç ~mtl~ —Ä–µ—à–∞–µ—Ç —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É

#+begin_src haskell
class Monad m => MonadReader r m | m -> r where
  ask :: m r
  --snip--

instance Monad m => MonadReader r (ReaderT r m) where
  --snip--

instance Monad m => MonadReader r (StateT s m) where
  ask = lift ask
  --snip--
#+end_src



#+begin_src haskell
class Monad m => MonadThrow m where
  throwM : Exception e => e -> m a

class MonadThrow m => MonadCatch m where
  catch :: Exception e => m a -> (e -> m a) -> m a
#+end_src

~ThrowError~ ‚Äì –∫–æ–≥–¥–∞ –Ω–∞–¥–æ —Å–ª–æ–º–∞—Ç—å –≤—Å–µ

–ú–æ–∂–µ–º –∏—Å–ø–æ–ª—å–æ–≤–∞—Ç—å ~deriving~ –∏ ~mtl~
#+begin_src haskell
newtype M a = M(ReaderT Environment (StateT MyState IO) a)
  deriving (Functor, Applicative, Monad, MonadIO, MonadState MyState, MonadReader Environment)
#+end_src

- –ó–∞–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å ~IO~ —Ç–æ–ª—å–∫–æ –≤ ~ReaderT~
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –º–æ–Ω–∞–¥—É, –µ—Å–ª–∏ –∫–æ–Ω–µ—á–Ω–æ –Ω–µ –ø–∏—à–∏—Ç–µ –ª–∏–±—É

* –õ–µ–∫—Ü–∏—è 13
[[http://slides.com/fp-ctd/lecture-10#/][–°–ª–∞–π–¥—ã]]

–ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è —Å–ø–∏—Å–∫–æ–≤ –∑–∞ O(1)
#+begin_src haskell
newtype DList a = DL { unDL :: [a] -> [a] }

fromList :: [a] -> DList a
fromList l = DL (l++)

toList :: DList a -> [a]
toList (DL lf) = lf []

append :: DList a -> DList a -> DList a
(DL f) `append` (DL g) = DL $ \xs -> f (g xs) -- append = mappend = <>
#+end_src

–û—Ç–∫–ª–∞–¥—ã–≤–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏–∏, –¥–æ —Ç–µ—Ö –ø–æ—Ä. –ø–æ–∫–∞ –Ω–∞–º –Ω–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è
—Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã—á–∏—Å–ª–∏—Ç—Å—è –∑–∞ –¥–ª–∏–Ω—É —Å–ø–∏—Å–∫–∞, –±–ª–∞–≥–æ–¥–∞—Ä—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É
–ø–æ—Ä—è–¥–∫—É –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ ~++~


–ò–≥—Ä—É—à–µ—á–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è ~seq~ ‚Äî —Ñ–æ—Ä—Å–∏—Ç –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –¥–æ WHNF
#+begin_src haskell
seq :: a -> b -> b
_|_ `seq` _ = _|_
_   `seq` b = b
#+end_src


- ~foldl~, ~foldr~ –º–µ–¥–ª–µ–Ω–Ω—ã–µ
- ~foldl'~ ‚Äî —Å—Ç—Ä–æ–≥–∞—è –≤–µ—Ä—Å–∏—è, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ~seq~

~deepseq~ –∫–∞–∫ ~seq~, –Ω–æ –≤—ã—á–∏—Å–ª—è–µ—Ç –¥–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º—ã. –ß—Ç–æ–±—ã –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä
–∑–Ω–∞–ª, –∫–∞–∫ –≤—ã—á–∏—Å–ª—è—Ç—å –≤–∞—à—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º—ã, –Ω—É–∂–Ω–æ
–∑–∞–∏–Ω—Å—Ç–∞–Ω—Å–∏—Ä–æ–≤–∞—Ç—å ~NFData~
#+begin_src haskell
class NFData a where
  rnf :: a -> ()
  rnf a = a `seq` ()

instance NFData a => NFData (Maybe a) where
  rnf Nothing = ()
  rnf (Just x) = rnf x

instance NFData a => NFData [a] where
  rnf [] = ()
  rnf (x:xs) = rnf x `seq` rnf xs


deepseq :: NFData a => a -> b -> b
a `deepseq` b = rnf a `seq` b
#+end_src

~-XBangPatterns~ ‚Äî –º–æ–∂–Ω–æ —Å—Ç–∞–≤–∏—Ç—å ~!~ –ø–µ—Ä–µ–¥ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º —á—Ç–æ–±—ã –≤—ã—á–∏—Å–ª–∏—Ç—å –µ–≥–æ –¥–æ WHNF
