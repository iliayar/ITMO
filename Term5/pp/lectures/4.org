#+setupfile: setup.org
#+TITLE: Лекция 4
#+date: 27 сентября

* Безусловные условия прогресса
- *Отсутствие помех (obstruction-freedom)* \\
  Если несколько потоков пытаются выполнить операцию, то любой из
  них должен выполнить ее за конечное время, если все другие потоки
  остановить в любом месте
- *Отсутсвие блокировки (lock-freedom)* \\
  Если несколько потоков пытаются выполнить операцию, то хотя бы один
  из них должен выполнить ее за конечное время (не зависимо от
  действия или бездейсвия других потоков)
- *Отсутсвие ожидания (wait-freedom)* \\
  Если какой-то поток пытается выполнить операцию, то он выполнит ее
  за конечное время (не зависимо от действия или бездействия других
  потоков)
* Базовые примитивы
- Общие регистры неатомарные.
  #+begin_definition org
  *Безопасный регистр* гарантирует получение последнего записанного
   значения, если операция чтения не параллельна операциям записи.
  #+end_definition
** Регулярный SRSW булев регистр
*Дано*: Безопасный SRSW булев регистр
#+begin_src python
def write(x):
    if x != last:
        last = x
        r = x
def read():
    return r
#+end_src
--- Это регулярный регистр. Представим регистр как число в унарной системе счисления
#+begin_src python
def write(x):
    r[x] = 0
    for i in range(x - 1, 0, -1):
        r[i] = 1

def read():
    for i in range(0, M - 1):
        if r[i] == 0:
            return i
#+end_src
Чтобы сделать из регулярного регистра атомарный, будем использовать версии
#+begin_src python
def write(x):
    lastWriteV++
    r = (x, lastWriteV)
def read():
    cur = r
    if cur.v > lastRead.v:
        lastRead = cur
    return lastRead.x
#+end_src
#+begin_theorem org
Не существует алгоритма построения атомарного регситра без ожидания,
которые использует конечное число регулярных регистров конечного
размера так, чтобы их писал только писатель, а читал только читатель
#+end_theorem
** Атомарный список состояния N регистров без блокировок
Если есть несколь атомарных перменных, то в общем случае операции с
ними как одной структурой *не атомарны*
#+begin_src python
def update(i, x) :
    r[i] = (x, r[i].v + 1)

def scan():
    old = copy()
    while True:
        cur = copy()
        if all(cur[i].v == old[i].v):
            return cur.x
        old = cur
#+end_src

