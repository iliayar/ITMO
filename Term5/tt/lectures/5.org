#+setupfile: setup.org
#+TITLE: Лекция 5
#+date: 5 октября

* Алгебраические термы
\[ T ::= a | (f\ T_1\dots T_n) \]
#+begin_examp org
\[ f\ (f_2\ a\ b)\ c \]
#+end_examp

** Подстановка переменных
- \(S_0: V \to T\) --- тождественно почти всюду (кроме конечного количества)
- \(T_1 = T_2\) --- уравнение \\
  /Решение/: таккая подстановка \(S\), что \(S(T_1) \equiv S(T_2)\)
#+begin_examp org
\[ f\ a\ (a\ b) = f\ (g\ c)\ b \]
_Положим_:
 - \(S_0(a) = g\ c\)
 - \(S_0(a) = g\ b\)
\[ S(f\ a\ (g\ b)) = f\ (g\ c)\ (g\ b) \]
#+end_examp
** Эквивалентность уравнений и систем
- \(E_1\)
  \begin{center}
  \begin{array}{l}
  T_1 = P_1 \\
  \vdots \\
  T_n = P_n
  \end{array}
  \end{center}
- \(E_2\)
  \begin{center}
  \begin{array}{l}
  T_1' = P_1' \\
  \vdots \\
  T_n' = P_n'
  \end{array}
  \end{center}
Если любое решение системы \(E_1\) подходит к \(E_2\) и наоборот
#+begin_statement org
Для системы \(\begin{cases}T_1 = P_1 \\ \vdots \\ T_n =
p_n\end{cases}\) существует эквивалентные уравнения
#+end_statement
#+begin_proof org
Выберем \(k\) --- новый ф.с. \(n\)-местный интервал
\[ T_1\ \dots\ T_n = h\ P_1\ \dots\ P_n \]
#+end_proof
#+begin_definition org
Определим порядок на подстановках: \(S \le T\), если \(S\) --- частный
случай \(T\): существует подстановка \(U\), что \(S = U \circ T\)
#+end_definition
#+begin_definition org
\[ U \circ T: (U \circ T)(P) = U(T(P)) \]
#+end_definition
#+begin_definition org
Наиболее общим решением \(T = P\) назовем подстановку \(S\), что для
любой \(S_1\): \(S_1(T) \equiv S_1(P)\) выполнено \(S_1 \le S\) и \(S(T) =
S(P)\)
#+end_definition

#+begin_theorem org
У уравнения в алгебраических термах \(T = P\) всегда есть наиболее
общее решение, если есть хоть какое-то
#+end_theorem

#+begin_definition org
Несовместные система: система с уравнением вида:
\[ f\ T_1\dots T_n = g\ P_1 \dots P_n \]
, где \(f \equiv g\)
_либо_ ``occurs check``\fixme
#+end_definition
#+begin_definition org
Система в разрешенной форме
\[ \begin{cases} a_1 = T_1 \\ \vdots \\ a_n = T_n \end{cases} \]
где
1. все \(a\) различны
2. \(T_i\) не содержит \(a_j\)
#+end_definition
** Алгоритм унификации
Рассмотрим систему
\[ \begin{cases} T_1 = P_1 \\ \vdots \\ T_n = P_n \end{cases} \]
Применение одного из следующих шагов
1. \(x = x\) --- отбрасываем
2. \(T = x\), где \(T \not\equiv x\) \( \implies x = T \)
3. \[ \begin{cases} x = P \\ \vdots \\ T_2 = P_2 \\ \vdots \\ T_n = P_n \end{cases} \implies \begin{cases} T_2[x \coloneqq P] = P_2[x \coloneqq P] \\ \vdots \\ T_n[X \coloneqq P] = P_n[x \coloneqq P] \\ \vdots \\ x = P \end{cases}\]
4. \(f\ T_1\ \dots\ T_4 = f\ P_1\ \dots\ P_n \implies\)
   \[ \begin{cases} T_1 = P_1 \\ \vdots \\ T_n = Pn \end{cases}\]
#+begin_theorem org
Применяя шаги алгоритма унификации, за конечное время можно получить
систему либо в разрешенной форме, либо несовместной
#+end_theorem
** Вывод типов в \(\lambda_\to\)
\((\to)\) --- двуместный функциональный символ \\
Индукция по структуре \(\lambda\)-выражения
1. \(x\) --- введем тип \(\alpha_x\). \\
   Система: \(\varnothing\) \\
   Тип: \(\alpha_x\)
1. \(A\ B\) --- рекурсивный вызов, \(\pair{E_A, \tau_A}, \pair{E_B, \tau_B}\) \\
   Система: \(E_A, E_B, \tau_B \to \beta = \tau_A\) \\
   Тип: \(\beta\)
1. \( \lambda x. A\) --- рекурсивный вызов \(\pair{E_A, \tau_A}\) \\
   Система: \(E_A\) \\
   Тип: \(\alpha_x \to \tau_A\)
_Разрешение системы_: унификация
#+begin_examp org
\[ \overbrace{\lambda x. \underbrace{x}_A}^B \]
- \(E_A = \varnothing\), \(\tau_A = \alpha_x\)
- \(E_B = \varnothing\), \(\tau_B = \alpha_x \to \alpha_x\)
\[ \begin{cases} \tau_A = \alpha \\ \tau_B = \alpha \to \alpha \end{cases} \]
--- эта система в разрешенной форме
\[ \vdash \lambda x. x : \alpha \to \alpha \]
#+end_examp
#+begin_definition org
Терм называется *слабо-нормализуемым*, если существует
последовательность \(\beta\)-редукция, приводящая его к нормальной форме
#+end_definition
#+begin_definition org
Терм --- *сильно-нормализуем*, если не существует бесконечной
последовательность \(\beta\)-редукций, не приводящая к нормальной форме
#+end_definition
#+begin_theorem org
\(\lambda_\to\) сильно нормализуемо
#+end_theorem
* Исчисление предикатов 2 порядка
Хотим писать \(\forall p. p \lor \lnot p\)
- \(\Phi_\Pi ::= p | \Phi_\Pi \lor \Phi_\Pi | \Phi_\Pi \& \Phi_\Pi | \Phi_\Pi \to \Phi_\Pi | \forall p. \Phi_\Pi | \exists p. \Phi_\Pi | \perp\)
#+begin_statement org
Можно выразить:
- \(a\&b ::= \forall p. (a \to b \to p) \to p\)
- \(a\lor b ::= \forall p. (a \to p) \to (b \to p) \to p\)
- \(\perp ::= \forall p. p\)
- \(\exists p. A ::= \forall x. (\forall p. A \to x) \to x\)
#+end_statement
#+begin_definition org
\(L_2\) -- лямбда исчисление 2 порядка (Система F)
\[ L_2 ::= x | \lambda x^\alpha. A | P\ Q  | \color{red} \Lambda \alpha. A| P\ \tau \]
#+end_definition
#+begin_examp org
\-
- \(id: \alpha \to \alpha\). \(id \equiv \Lambda \alpha. \lambda x^\alpha. x\), \(id\ (Int)\ 5\)
#+end_examp

* Практика
** ДЗ 3.6
\[ A^{\eta \to \eta \to \eta}\ M^\eta\ N^\eta\ f^{\alpha \to \alpha}\ a: \alpha : \alpha \]
- \( \vdash x : \eta, \alpha \to \alpha, \alpha \)
- \(P\ Q\) ?
- \(( \lambda x^\tau. P^\pi)^{\tau \to \pi}\ A^\tau : \pi\), \(\pi \equiv \alpha\)
  Гиганский тип выражения \(A\) окажется в переменной \(x\) в \(P\)
** Черчевский нумералы в F
\[ \Lambda \alpha. \lambda f^{\alpha \to \alpha} . \lambda x^\alpha. f\dots f(x) : \eta : \forall \alpha. (\alpha \to \alpha) \to \alpha \to \alpha \]
\[ (+) = \Lambda \alpha. \lambda a^\eta. \lambda b^\eta. \lambda f^{\alpha \to \alpha}. \lambda x^\alpha. (a\ \alpha)\ f\ ((b\ \alpha)\ f\ x)  \]
** Правила
\[ \frac{\Gamma \vdash A : \varphi}{\Gamma \vdash \Lambda \alpha. A : \forall \alpha. \varphi} \]
\[ \frac{\Gamma \vdash A : \forall \alpha. \varphi}{\Gamma \vdash A\ \pi : \varphi[\alpha \coloneqq \pi]} \]

