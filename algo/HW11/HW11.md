### Homework 11

#### Task 1
Дольше всего такой алгоритм будет работать только в том случае, когда каждый элемент будет просеиваться до самого верха. Тогда:
$$ T(n) = \sum_{i=1}^n \log i = \log n!\\
\log n! \le \log n^n\\
T(n) = O(n\log n)$$

#### Task 2
$$C_r = 0, r \gt n\\
C_r^n = 1, r \gt n-2\\
C_r^n = 2^{n-2}, r \le n-2$$


#### Task 4
Представим кучу $H$ в виде двоичного числа. Тогда при слиянии ее с кучей размером $H' = 1$ произойдет столько слияний, сколько единиц стоит подряд в двоичном представлении кучи $H$ начиная с младшего разряда.

#### Task 5
$$n\tilde{T}(insert) = \sum_{i=0}^{\log n}\frac{n}{i}\\
n\tilde{T}(insert) \le 2n\\
\tilde{T}(insert) \le 2\\
\tilde{T}(insert) = O(1)$$

#### Task 6
Добавим в список вершин обратную связь. Так-же заведем список в котором будем хранить указатели на двойки. Тогда при добавлении нового элемента сначала будем брать младшую двойку, если она есть, убирать указатель на нее из списка и сливать эту двойку, затем проверим образует ли новая куча двойку, если да то добавим ее в список.
Затем добавим кучу размером $1$ и провери образует ли она двойку, если да то добавим ее в список.
Таким образом: $T(insert) = O(1)$

#### Task 7
Присвоим этому элементу минимально возможное значение. Просеим его вверх за $O(\log n)$. Затем удалим минимальный элемент за $O(\log n)$.

#### Task 8
Представим поддерево с вершиной которой надо увеличить ключ как две кучи: одна будет содержать единственный элемент, эту вершину, другая - все дети этого элемента. Тогда операция мердж этих двух куч $O(\log n)$.

#### Task 9
Будем работать с деревьями по правилам Фибоначиевой системы счисления. То есть если мерджим два равных дерева размера $f(n)$ то раскладываем их на деревья размером $f(n+1)$ и $f(n-2)$. Так же если встерчается два дерева размерами $f(n)$ и $f(n+1)$ то собираем их в дерево $f(n+2)$. Ассимптотически время работы операций на такой структуре будет примерно равно логорифму. 